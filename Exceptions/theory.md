<details><summary>Дайте определение понятию “исключение” (Зачем в целом они нам нужны)</summary>
    <p><b>Исключение</b> - ошибка и/или непредвиденная ситуация при выполнении программы. Исключение представляет
    собой объект, описывающий эту ситуацию,
    возникающую в определенной части программного кода.</p>
    <p>Исключения нужны для того чтоб не останавливалось выполнение программы</p>
</details>

<details><summary>Какова иерархия исключений. (Почему она сформирована таким образом)</summary>
    <img src="https://i2.wp.com/proselyte.net/wp-content/uploads/2016/03/Checked-and-Unchecked-Exceptions-in-Java.png">
</details>

<details><summary>Методы Throwable</summary>
    <ul>
        <li><b>final void addSuppressed(Throwable исключение)</b> - добавляет заданное исключение в список подавляемых 
            исключений. Этот список связывается с вызывающим (данным) исключением. Метод используется для применения в операторе 
            try с ресурсами
        </li>
        <li><b>Throwable getCause()</b> - возвращает исключение, лежащее в основе текущего исключения. Метод возвращает null в случае,
            если такое исключение отсутствует. Этот метод используется при создании цепочек исключений
        </li>
        <li><b>String getMessage()</b> - возвращает описание исключения</li>
        <li><b>printStackTrace()</b> - выводит трассировку стека</li>
        <li><b>StackTraceElement[] getStackTrace()</b> - возвращает массив, содержащий поэлементную трассировку стека в виде объектов класса StackTraceElement</li>
        <li><b>final Throwable[] getSuppressed()</b> - получает подавленные исключения, связанные с вызывающим исключением, и возвращает массив, который содержит 
            результат. Подавленные исключения генерируются в операторе try с ресурсами
        </li>
        <li><b>void setStackTrace(StackTraceElement элементы[])</b> - устанавливает трассировку стека для заданных элементов</li>
        <li><b>Throwable fillInStackTrace()</b> - возвращает объект класса Throwable, содержащий полную трассировку стека. Этот объект может быть сгенерирован повторно</li>
    </ul>
</details>

<details><summary>Как ведет себя программа при вбрасывании исключения. (Каким образом мы можем влиять на это поведение)</summary>
    <p>Если во время выполнения программы происходит ошибка, то генерируется исключение. Если исключение сгенерировалось вне блока
    обработки исключений (try), то это исключение обрабатывается стандартным обработчиком исключений. Который выводит информацию
    об этом исключении и прерывается выполнение программы.</p>
    <p>Если исключение было сгенерированно в блоке try, то выполнение программы переъодит в блок catch, затем в блок final и
    после этого продолжается нормальное выполнение программы</p>
</details>

<details><summary>Каким образом ты можешь отловить исключения (все доступные)</summary>
    <ul>
        <li>   
            <ul>блок try-catch-finally
                <li>обычный блок try-catch или try-finally</li>
                <li>несколько catch</li>
                <li>несколько исключений в catch: catch(SomeException1 || SomeException2 e){}</li>
            </ul>
        </li>
        <li>"throws" - в сигнатуре метода</li>
        <li>реализовать интерфейс Thread.UncaughtExceptionHandler и засетить реализованный экземпляр в Thread.setDefaultUncaughtExceptionHandler</li>
    </ul>
</details>

<details><summary>Написание собственного исключения (подумать о том, какой смысл в написании собственных исключений)</summary>
    <p>Для создания своего исключения, надо расширить класс Exception или от его производных.</p>
    <p>Собстенные исключения нужны для того, чтоб мы могли описать конкретную исключительную ситуацию, которая
    может возникнуть в нашем коде</p>
</details>

<details><summary>Почему "грязно" закрывать конекшн внутри try блока</summary>
    <p></p>
</details>