<details><summary>Работа List? В каких ситуациях использовать</summary>
    <p><b>List</b> - это тип данных, в котором каждый элемент содержит какой-то контент (объект сылочного типа данных),
        а также ссылку на следующий элемент списка
    </p>
    <p>Интерфейс List объединяет несколько реализаций: <b>ArrayList, LinkedList, Vector, Stack</b></p>
    <img src="https://vertex-academy.com/tutorials/wp-content/uploads/2018/06/list-java-vertex-academy.png" width="30%" ><br>
    <p>Основное преимущество списка по сравнению с массивом - его можно легко расширять</p>
    <ul>методы:
        <li><b>int size()</b></li>
        <li><b>boolean isEmpty()</b></li>
        <li><b>boolean contains(Object o)</b></li>
        <li><b>Iterator&lt;E&gt; iterator()</b></li>
        <li><b>Object[] toArray()</b></li>
        <li><b>boolean add(E e)</b></li>
        <li><b>boolean remove(Object o)</b></li>
        <li><b>boolean containsAll(Collection&lt;?&gt; c)</b></li>
        <li><b>boolean addAll(Collection&lt;? extends E&gt; c)</b></li>
        <li><b>void clear()</b></li>
        <li><b>E get(int index)</b></li>
        <li><b>E set(int index, E element)</b></li>
        <li><b>int indexOf(Object o)</b></li>
        <li><b>int lastIndexOf(Object o)</b></li>
        <li><b>of(E... elements)</b> - статические методы</li>
        <li><b>default void replaceAll(UnaryOperator&lt;E&gt; operator)</b> - default method</li>
        <li><b>default void sort(Comparator&lt;? super E&gt; c)</b> - default method</li>
    </ul>
    <ul>использование когда:
        <li>есть элементы, которые могут повторяться</li>
        <li>нужен доступ к элементам по индексу</li>
        <li>возможны null</li>
    </ul>
</details>

<details><summary>Работа ArrayList</summary>
    <p>ArrayList одна из реализаций интерфейса List. В основе ArrayList лежит идея динамического массива, с возможностью
        добавлять и удалять элементы, при этом будет увеличиваться или уменьшаться по мере необходимости
    </p>
    <ul>Конструкторы:
        <li>public ArrayList()</li>
        <li>public ArrayList(int initialCapacity)</li>
        <li>public ArrayList(Collection&lt;? extends E&gt; c)</li>
    </ul>
    <p>При инициализации ArrayList с помощью конструктора без параметров, под капотом, создается массив <b>elementData</b>
    с дефолтным количеством элементов <b>capacity</b> 10 типа Object.
    </p>
    <p>Так же можно инициализировать ArrayList с определенным кол-вом элементов, используя конструктор <b>public ArrayList(int initialCapacity)</b>,
    в случаи передачи 0 - будет инициализирован пустой массив, при передаче отрицательного значения будет выбрашено исключение IllegalArgumentException
    </p>
    <ol>Добавление элементов: list.add("0"):
        <li>проверяется, достаточно ли места в массиве для вставки нового элемента: ensureCapacity(size + 1);</li>
        <li>если достаточно, элемент добавляется в конец массива: elementData[size++] = element;</li>
        <li>если нет, вызывается метод grow(size + 1) в котором производится увеличение capacity, затем
            копирование существующего массива в новый, с учетом нового размера (capacity) где в конечном итоге вызывается
            нативный метод: System.arraycopy()
        </li>
    </ol>
    <ol>Добавление в «середину» списка: list.add(5, "100"):
        <li>проверяется, достаточно ли места в массиве для вставки нового элемента: ensureCapacity(size+1);</li>
        <li>подготавливается место для нового элемента с помощью: System.arraycopy()</li>
        <li>перезаписывается значение у элемента с указанным индексом: elementData[index] = element; size++;</li>
    </ol>
    <ol>Удаление элементов по индексу:
        <li>Определяется какое количество элементов надо скопировать: int numMoved = size - index - 1;</li>
        <li>затем копируем элементы используя System.arraycopy()</li>
        <li>Уменьшается размер массива и последнему элементу присваивается null: elementData[--size] = null</li>
    </ol>
    <p>При удалении по значению, в цикле просматриваются все элементы списка, до тех пор пока не будет найдено соответствие. Удален будет лишь первый найденный элемент.</p>
</details>

<details><summary>Работа LinkedList</summary>
    <p><b>LinkedList</b> одна из реализаций List, которая еще реализует интерфейс Deque, что обеспечивает создание связанного списка
        в виде двунаправленной очереди. Который позволяет хранить элементы любого ссылочного типа данных.
    </p>
    <p>Каждый элемент этого списка является узлом (объектом внутреннего класса Node), который хранит ссылки на следующий и предыдущий элемент
        этой коллекции, а так же ссылку на сам элемент помещенный в эту коллекцию
    </p>
    <ul>Конструкторы:
        <li>public LinkedList()</li>
        <li>public LinkedList(Collection&lt;? extends E&gt; c)</li>
    </ul>
    <p><b>Создание связанного списка</b>: LinkedList&lt;Integer&gt list = new LinkedList&lt;&gt()<br>
        после создание экземпляра LinkedList, внутри у него создаются поля:<br>
        int size = 0;<br>
        Node&lt;E&gt; first;<br>
        Node&lt;E&gt; last;
    </p>
    <p><b>Добавление объекта в конец связанного списка</b>: list.add(8)<br>
        Создается объект элемента, создается объект узла (Node), которому в поле item задается значение элемента.
        Так же задаются поля next и prev ссылками на следующий и предыдущий узел списка соответственно. Изменяется поле size списка.
        Если это был первый элемент списка по поля узла next и prev будут иметь null ссылки 
    </p>
    <p><b>Добавление следующего элемента:</b><br>
        Сначала создается узел для нового элемента и устанавливается ссылка в поле prev на существующий элемент предыдущего узла коллекции,
        а следующим элементом у созданного узла остается null. Также этот новый узел сохраняется в переменную связанного списка last
    </p>
    <ol><b>Добавление объекта в середину связанного списка:</b>list.add(1, 13);
        <li>Сначала осуществляется проверка значения index, которое должно быть положительным числом, меньшим или равным размеру списка</li>
        <li>Если index равен размеру коллекции, то осуществляются действия, по вставке элемента в конец существующего списка</li>
        <li>Если же index не равен size списка, то осуществляется вставка перед элементом, который до этой вставки имеет заданный индекс</li>
        <li>С помощью метода node(index) определяется узел, находящийся в данный момент под индексом, под который нам необходимо вставить новый узел. 
            Поиск данного узла осуществляется с помощью простого цикла for
        </li>
        <li>Создается узел для нового элемента, устанавливается ссылка на предыдущий элемент и на следующий элемент</li>
    </ol>
    <p>Методы для удаления элементов: <br>
        <img src="https://habrastorage.org/r/w1560/web/52e/b4d/075/52eb4d07565e444e966ebeb652dd8202.jpg" width="50%">
    </p>
    <ol>Удаление элемента из связанного списка по его значению: list.remove(someObject);
        <li>Искомый объект сравнивается по порядку со всеми элементами, сохраненными в узлах списка, начиная с нулевого узла</li>
        <li>Когда найден узел, элемент которого равен искомому объекту, первым делом элемент сохраняется в отдельной переменной</li>
        <li>Переопределяются ссылки соседних узлов так, чтобы они указывали друг на друга</li>
        <li>Затем обнуляется значение узла, который содержит удаляемый объект, а также уменьшается размер коллекции</li>
    </ol>
</details>
<details><summary>ArrayList vs Linked List? В том числе с точке зрения перфоманса?</summary>
    <ol>Преимущества ArrayList
        <li>Возможность доступа к произвольному элементу по индексу за постоянное время</li>
        <li>Минимум накладных расходов при хранении такого списка</li>
        <li>Вставка в конец списка в среднем производится так же за постоянное время</li>
        <li>Удаление последнего элемента происходит за константное время</li>
        <li>Тк в основе массив - а массив в памяти хранится как непрерывный набор данных, что дает преимущества в производительности</li>
    </ol>
    <ol>Недостатки ArrayList
        <li>При вставке/удалении элемента в середине списка — это взывает перезапись всех элементов размещенных «правее»</li>
        <li>При удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize()</li>
    </ol>
    <ol>Преимущества LinkedList 
        <li>Вставка/удаление/получение элементов из начала и конца списка происходит за константное время</li>
    </ol>
    <ol>Недостатки LinkedList 
        <li>Все операции из середины списка выполняются в среднем за линейное время</li>
        <li>Больше накладных расходов памяти, тк для содержаниея одного элемента, создаются еще ссылки на пред. и след. элементы,
            при удалении элементов они перезаписываются null, и ожидают gc
        </li>
    </ol>
    <table>
        <thead>
            <tr>
                <td style="border:solid 2px">Operation</td>
                <td style="border:solid 2px">ArrayList</td>
                <td style="border:solid 2px">LinkedList</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>add (в начало)</td>
                <td>O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>add (в середину)</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>
            <tr  style="border-bottom:solid 2px">
                <td>add (в конец списка)</td>
                <td>O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>get (первый элемент)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>get (из середины)</td>
                <td>O(1)</td>
                <td>O(n)</td>
            </tr>
            <tr  style="border-bottom:solid 2px">
                <td>get (последний элемент)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>delete (первый элемент)</td>
                <td>O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>delete (из середины)</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>
            <tr  style="border-bottom:solid 2px">
                <td>delete (последний элемент)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
        </tbody>
    </table>
    <p><b>LinkedList</b> - стоит использовать когда нам предстоит очень много операций вставки/удаления в начале и конце списка</p>
    <p>В остальных случаях лучше использовать <b>ArrayList</b>. ArrayList более предсказуем для процессора, с точки зрения расположения 
        данных. Это массив, а там элементы расположены последовательно, занимая непрырывную область памяти. Это хорошо, так как 
        позволяет подгружать данные в кэши процессора без cache miss'ов. Процессор не простаивает, ожидая данные из оперативной памяти.
        С LinkedList такого нет, т.к. элементы располагаются в разных участках памяти, и предугадать расположение следующего элемента процессору не под силам.</p>
</details>
<details><summary>Работа Set? В каких ситуациях использовать? Плюсы и минусы Set?</summary>
    <p><b>Set</b> представляет набор уникальных элементов. Set расширяет интерфейс Collection. Set не добавляет новых методов, только вносит изменения унаследованные.
        В частности, метод add() добавляет элемент в коллекцию и возвращает true, если в коллекции еще нет такого элемента.</p>
    <ul><b>Set</b> имеет 3 часто используемых реализации:
        <li><b>HashSet</b> - хранит элементы в произвольном порядке, но быстро ищет. Подходит, если порядок не важен, но важна скорость</li>
        <li><b>LinkedHashSet</b> - хранить элементы в порядке добавления, работает медленней</li>
        <li><b>TreeSet</b> - хранит элементы отсортированными</li>
    </ul>
</details>
<details><summary>Set vs List?</summary>
    <ul>Различия:
        <li>List может хранить дублирующиеся элементы, Set - нет</li>
        <li>List поддерживает порядок вставки, Set - нет</li>
        <li>List может хранить любое количество null, Set - только одно значение</li>
        <li>List может предоставить элемент по индексу, Set - нет</li>
        <li>Для перебора элементов List использует ListIterator(двунаправленный перебор), Set - Iterator</li>
    </ul>
</details>
<details><summary>HashSet</summary>
    <p><b>HashSet</b> реализует интерфейс Set, основан на хэш-таблице, а также поддерживается с помощью экземпляра HashMap</p>
    <ul>Конструкторы:
        <li><b>public HashSet()</b> - инициализирует пустую HashMap</li>
        <li><b>public HashSet(int initialCapacity)</b></li>
        <li><b>HashSet(int initialCapacity, float loadFactor, boolean dummy)</b> - инициализирует новый пустой linked hash set</li>
    </ul>
    <ul>Методы:
        <li><b>public boolean add(E e)</b> - выполняет map.put(e, PRESENT)</li>
        <li><b>public boolean remove(Object o)</b> - map.remove(o)</li>
        <li><b>size()</b></li>
        <li><b>isEmpty()</b></li>
        <li><b>contains(Object o)</b></li>
        <li><b>public Object[] toArray()</b></li>
    </ul>
    <p>HashSet основан на HashMap, где элементами являются ключи, а значения HashMap заполняются пустыми объектами</p>
    <p>Мы не можем получить элементы по отдельности из HashSet, может только итерироваться по всем элементам, и получить в виде массива
        используя методы toArray
    </p>
    <ul>Поведение:
        <li>HashMap — это массив бакетов с емкостью по умолчанию 16 элементов. Каждый бакет хранит в себе элементы в виде связанного списка.
            Бакет определяется с помощью побитовых операций над хеш-кодом объекта.            
        </li>
        <li>Если для разных объектов с разными хеш-кодами был определен один и тот же бакет - они в нем будут хранится в виде связанного списка</li>
        <li>Если коэффициент загрузки достигнут, создается новый массив, вдвое превышающий размер предыдущего, и все элементы повторно хешируются 
            и перераспределяются между новыми соответствующими корзинами
        </li>
        <li></li>
    </ul>
</details>
<details><summary>Hash Code?</summary>
    <p><b>Хеш-функция</b> - функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку 
        установленной длины, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, называется хешированием. 
        Исходные данные называются входным массивом
    </p>
    <p>Относительно Java метод hashCode() является хеш-функцией. Этот метод есть у каждого класса, тк этот метод объявлен в классе Object.</p>
    <p>hashCode() возвращает значение (хеш-код) типа int, соответственно множество этих значений ограничено диапазоном примитивного типа int</p>
    <ul>Контракт hashCode:
        <li>для одного и того-же объекта, хеш-код всегда будет одинаковым</li>
        <li>если объекты одинаковые, то и хеш-коды одинаковые</li>
        <li>если хеш-коды равны, то входные объекты не всегда равны (коллизия)</li>
        <li>если хеш-коды разные, то и объекты гарантированно разные</li>
    </ul>
</details>
<details><summary>Как HashSet поддерживает уникальность</summary>
    <p>За счет hashCode и equals</p>
</details>
<details><summary>Производительность HashSet?</summary>
    <p>На производительность HashSet влияют в основном два параметра — его Initial Capacity и Load Factor</p>
    <p>Ожидаемая сложность алгоритма добавления элемента в набор составляет O(1), которая может упасть до O(n) 
        в худшем случае (присутствует только одна корзина) — поэтому важно поддерживать правильную емкость HashSet
    </p>
    <p>Важное примечание: начиная с JDK 8 временная сложность в наихудшем случае составляет O(log*n)</p>
    <ul>Компромис выбора Capacity и Load Factor
        <li>Высокая начальная емкость хороша для большого количества записей в сочетании с небольшим количеством итераций или без них</li>
        <li>Низкая начальная емкость хороша для нескольких записей с большим количеством итераций</li>
    </ul>
</details>
<details><summary>LinkedHashSet</summary>
    <p>LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в 
        том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор
    </p>
    <ul>Кщнструкторы:
        <li>
            <b>public LinkedHashSet()</b> - который вызывает конструктор HashSet: super(16, .75f, true) - в результате чего инициализируется LinkedHashMap
        </li>
        <li>...все конструкторы вызывают конструкторs суперкласса HashSet - передавая туда параметры - в результате чего инициализируются LinkedHashMap</li>
    </ul>
</details>
<details><summary>EnumSet? Преимущества перед другими сет?</summary>
    <p><b>EnumSet</b> специализированная реализация Set, предназначенная для работы с Enum.</p>
    <p>Так как EnumSet это абстрактный класс, то мы не можем создать инстанс напрямую. Но у него есть статические фабричные методы для создания экземпляров</p>
    <ul>2 реализации EnumSet
        <li><b>RegularEnumSet</b> - использует один длинный объект для хранения элементов EnumSet. Каждый бит длинного элемента представляет значение Enum. 
            Поскольку размер long составляет 64 бита, он может хранить до 64 различных элементов
        </li>
        <li><b>JumboEnumSet</b> - использует массив long, для хранения элементов EnumSet. Единственное отличие от RegularEnumSet заключается в том,
            что JumboEnumSet использует long массив для хранения битового вектора, что позволяет хранить более 64 значений.
        </li>
    </ul>
    <ul>Особенности:
        <li>Расширяет AbstractSet и реализует Set</li>
        <li>EnumSet не синхронизированная</li>
        <li>Высокопроизводительная коллекция, быстрей чем HashSet</li>
        <li>Все элементы в EnumSet должны исходить из одного типа перечисления, который указывается при создании набора явно или неявно</li>
        <li>Не допускает <b>null</b></li>
        <li>Он использует <b>fail safe</b> (отказоустойчивый) итератор, поэтому он не бросает исключение ConcurrentModificationException,
            если коллекция будет изменена во время итерации
        </li>
        <li>Представляет паттерн Фабрика для инициализации объектов</li>
    </ul>
    <ol>Преимущества EnumSet:
        <li>EnumSet быстрее, чем HashSet, потому что нам не нужно вычислять хэш-код, чтобы найти нужное ведро</li>
        <li>Вычисления выполняются за постоянное время, а требуемое пространство очень мало</li>
    </ol>
    <ul>Методы:
        <li><b>allOf(Class&lt;E&gt; elementType)</b> - создает коллекцию из всех значений переданного класса перечисления</li>
        <li><b>complementOf(EnumSet&lt;E&gt; s)</b> - создает набор перечислений с тем же типом элементов, что и указанный набор
            перечислений, изначально содержащий все элементы этого типа, не содержащиеся в указанном наборе
        </li>
        <li><b>noneOf(Class&lt;E&gt; elementType)</b> - создает пустой набор enum с указанным типом элемента</li>
        <li><b>range(E from, E to)</b> - Создает набор перечислений, первоначально содержащий все элементы в диапазоне,
            определяемом двумя указанными конечными точками
        </li>
        <li><b>of</b> - различные вариации создания набора из перечислений</li>
    </ul>
</details>
<details><summary>TreeSet</summary>
    <p><b>TreeSet</b> — это отсортированная коллекция, которая расширяет класс AbstractSet и реализует интерфейс NavigableSet</p>
    <p>TreeSet использует самобалансирующееся бинарное дерево поиска, точнее красно-черное дерево.</p>
    <ul>Особенности:
        <li>Хранит уникальные элементы</li>
        <li>Он не сохраняет порядок вставки элементов</li>
        <li>Сортирует элементы относительно переданного компаратора или реализованного Comparable в классе объекта</li>
        <li>Не синхронизированный</li>
        <li>До Java 7 можно было добавлять пустые элементы в пустой TreeSet. После - нет</li>
    </ul>
    <p>Производительность: По сравнению с HashSet производительность TreeSet ниже. Такие операции, как добавление, удаление
        и поиск, занимают O(log n) времени, в то время как такие операции, как печать n элементов в отсортированном порядке,
        требуют O(n) времени
    </p>
</details>
<details><summary>Как работает Красно - Черное дерево?</summary>
    <p><b>Красно-чёрное дерево</b> — один из видов самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический 
        рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление 
        и поиск узла. Сбалансированность достигается за счёт введения дополнительного атрибута узла дерева — «цвета». Этот атрибут 
        может принимать одно из двух возможных значений — «чёрный» или «красный».
    </p>
    <ol>Свойства:
        <li>Для каждого узла с ключом $ k $ выполняется критерий упорядочения: ключи всех левых потомков < k < ключи всех правых потомков</li>
        <li>Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета)</li>
        <li>Корень окрашен в черный цвет</li>
        <li>Листья (так называемые NULL-узлы) окрашены в черный цвет</li>
        <li>Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть 
            черные дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные
        </li>
        <li>Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота)</li>
    </ol>
    <p>Соблюдение свойств красно-черного дерева позволяет обеспечить выполнение операций вставки, удаления и выборки за время O(log n)</p>
    <a href="https://habr.com/ru/post/555404/">Понимаем красно-черное дерево</a>
</details>