<details><summary>Что такое модель памяти Java и зачем нам так важно знать как она работает?</summary>
    <p>Модель памяти Java описывает поведение потоков в среде исполнения Java</p>
    <ul>Для чего нам надо знать, понимать как и куда расходуется память:
        <li>чтоб писать оптимальные, относительно памяти, программы</li>
        <li>избегать утечек памяти</li>
        <li>решать проблемы и ошибки вызванные недостатком памяти</li>
    </ul>
    <img src="https://user-images.githubusercontent.com/4215285/73688549-55d59980-46dd-11ea-89d2-06ab5afdf423.png" >
</details>
<details><summary>Что такое стек память?</summary>
    <p>Стек работает по принципу LIFO (последний вошел - первый вышел). Когда вызывается метод, для него выделяется
        блок памяти (frame), в котором хранятся значения примитивов, создаваемых в методе, и ссылки на объекты в куче, на которые ссылается метод
    </p>
    <p>Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд, очищается, и пространство становится доступным для 
        следующего метода. При этом поток выполнения программы возвращается к месту вызова этого метода с последующим переходом к следующей строке кода
    </p>
    <ul>Особенности:
        <li>Он заполняется и освобождается по мере вызова и завершения новых методов</li>
        <li>Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы</li>
        <li>Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError</li>
        <li>Доступ к этой области памяти осуществляется быстрее, чем к куче</li>
        <li>Является потокобезопасным, поскольку для каждого потока создается свой отдельный стек</li>
    </ul>
</details>
<details><summary>Heap память</summary>
    <p>Heap память - это область памяти используется для динамического выделения памяти для объектов и классов JRE во время выполнения</p>
    <p>Эти объекты имеют глобальный доступ и могут быть получены из любого места программы</p>
    <ul>Heap состоит из:
        <li><b>Young Generation</b> - область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора</li>
        <li><b>Old (Tenured) Generation</b> - здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают определенного порога «возраста», они перемещаются в Old Generation</li>
        <li><b>Permanent Generation</b> - содержит метаинформацию о классах и методах приложения, но начиная с Java 8 данная область памяти была упразднена</li>
    </ul>
    <ul>Особенности:
        <li>Когда эта область памяти полностью заполняется, Java бросает java.lang.OutOfMemoryError</li>
        <li>Доступ к ней медленнее, чем к стеку</li>
        <li>Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется сборщик мусора</li>
        <li>В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код</li>
    </ul>
</details>
<details><summary>Где хранятся примитивные данные?</summary>
    <p>Значения полей примитивного типа, хранятся в куче</p>
    <p>Значения переменных (локальные переменные метода) примитивного типа хранятся в стеке</p>
</details>
<details><summary>Как строки представлены в памяти?</summary>
    <a href="https://javadevblog.com/chto-takoe-pul-strok-v-java.html" >Что такое пул строк в Java?</a>
    <p><b>Пул строк</b> - область памяти в куче, где JVM хранит строки</p>
    <p>каждый строковый литерал, будет храниться в пуле строк. Два объекта, проинициализированные эквивалентным строковым литералом
        будут иметь ссылки на один и тот же объект в пуле строк. Тк при инициализации, проверяется, есть ли в пуле строк такая страка,
        если есть, то возвращается ссылка на нее, если нет - то создается новая страка в пуле - этот процесс называется интерирование строк
    </p>
    <p>При инициализации строк с помощью new - в куче всегда создается новый объект типа String</p>
    <p>До Java 7 пул строк распологался в специальном участке памяти <b>PermGen</b>, который имел фиксированную длину и не
        расширялся во время выполнения программы и не доступен для сборки мусора. Это повышало риск получить OutOfMemoryError при большом количестве итерирования строк
    </p>
    <p>Начиная с Java 7 пул строк распологается в куче, что дает доступ сборщику мусора. Тем самым оптимизирую память и уменьшение риска получения OutOfMemoryError</p>
    <p>В Java 6 единственная оптимизация по увеличению памяти PermGen (где находился пул строк) - это только во время вызова программы с параметром:<br>
        -XX:MaxPermSize=1G
    </p>
    <p>Начиная с Java 7:<br>
        -XX:StringTableSize=4901
    </p>
</details>
<details><summary>Можно ли руками контролировать размеры heap памяти?</summary>
    <p>При запуске программы, в зависимости от системы, JVM выделяет значения памяти по умолчанию. При желании мы можем изменить эти значения
        при запуске приложения указать параметры:<br>
        <b>-Xms</b> - определяет минимальный объем heap памяти<br>
        <b>-Xmx</b> - определяет максимальный объем heap памяти<br>
        -Xms должен быть меньше, чем -Xmx
    </p>
</details>
<details><summary>Что такое сурвы? как они работают?</summary>
    <a href="https://habr.com/ru/company/otus/blog/553996/">Избавляемся от мусора в Java</a><br>
    <img src="https://hsto.org/r/w1560/getpro/habr/upload_files/0fd/29a/713/0fd29a71366c3832002a9c8a9ca6266a.png" width="50%">
    <p><b>Поколение объекта</b> - возраст объекта, т.е. количество пережитых циклов сборки мусора.</p>
    <p>Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области (Eden, S0, S1, OldGen). В эти области объекты помещаются в зависимости от их возраста.</p>
    <ol>Принцип работы:
        <li>Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые
        <li>Когда область Eden заполняется, происходит минорная сборка мусора. <b>Minor GC</b> — это процесс, при котором операции mark и sweep выполняются для young generation</li>
        <li>После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью удаляются</li>
        <li>По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты 
            перемещаются в область S1, и их возраст увеличивается (отметка о том, что они пережили сборку мусора)  
        </li>
        <li>При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются</li>
        <li>Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old</li>
        <li>При Major GC этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с Minor GC, поскольку старое поколение в основном состоит из живых объектов</li>
    </ol>
</details>
<details><summary>Что такое сбор мусора и в чем его преимущества?</summary>
    <p>Сборка мусора - это процесс освобождения памяти за счет удаления неиспользуемых объектов </p>
    <p>Для сборки мусора используется алгоритм пометок (Mark & Sweep)</p>
    <ol>Этапы сборки мусора:
        <li><b>Mark (маркировка)</b> - GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" </li>
        <li><b>Sweep (очистка)</b> - освобождается память, занятая объектами, не отмеченными на предыдущем шаге</li>
        <li><b>Compact (уплотнение)</b> - Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты</li>
        <img src="https://hsto.org/r/w1560/getpro/habr/upload_files/8f7/f4a/25f/8f7f4a25f345824f3b18b93d491aced9.png" width="50%">
    </ol>
    <ul>Преимущества:
        <li>Безопасность</li>
        <li>Упрощает процесс программирования</li>
        <li>Сокращает проблемы по управлению памяти</li>
    </ul>
    <ul>Недостатки:
        <li>остановка приложения во время работы gc (Stop the World)</li>
        <li>Возможно нееффективное использование памяти</li>
    </ul>
</details>
<details><summary>Что означает термин «Остановить мир» (Stop the World)?</summary>
    <p><b>Stop the World</b> - это полная остановка потоков программы для безопасной сборки мусора и других системных операций</p>
</details>
<details><summary>Виды сборщиков мусора в Java?</summary>
    <p><b>Serial Garbage Collector (последовательный)</b> - самый простой вариант для приложений с небольшим объемом данных и не 
        требовательных к задержкам. Хорош для использования в однопоточных средах. На слабых компьютерах может быть выбран
        виртуальной машиной в качестве сборщика по умолчанию
    </p>
    <p><b>Parallel (параллельный)</b> - наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в 
        некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности
    </p>
    <p><b>Concurrent Mark Sweep (CMS)</b> - нацелен на снижение максимальных задержек путем выполнения части работ по сборке 
        мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти
    </p>
    <p><b>Garbage-First (G1)</b> - создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных</p>
</details>
<details><summary>Базовый флоу работы каждого из них</summary>
    <a href="https://habr.com/ru/post/269707/" >Часть 2 — Сборщики Serial GC и Parallel GC.</a><br>
    <a href="https://habr.com/ru/post/269863/" >Часть 3 — Сборщики CMS GC и G1 GC</a>
    <ul>
        <li><b>Serial</b> -XX:+UseSerialGC</li>
        <li><b>Parallel GC</b> -XX:+UseParallelGC
            <p>
                Принцип работы основан как и у Serial GC память разбивается на 4 участка, только работа производится в нескольких потоках.
                Для определения количества потоков, которые будут использоваться при сборке мусора, на компьютере с N ядрами процессора, 
                JVM по умолчанию применяет следующую формулу: если N ≤ 8, то количество потоков равно N, иначе для получения количества 
                потоков N домножается на коэффициент, зависящий от других параметров, обычно это 5/8, но на некоторых платформах коэффициент может быть меньше
            </p>
            <p>
                Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый буфер повышения (promotion buffer), куда только 
                он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие 
                в виде возможной фрагментации памяти
            </p>
        </li>
        <li><b>CMS GC (Concurrent Mark Sweep)</b> - альтернатива Parallel GC
            <p>
                Шаги по пометке выживших объектов и удалению мертвых объектов он выполняет параллельно с работой основной программы.
                Имеет такие же части кучи, и малую сборку производит так же каки Serial/Parallel GC. Он не дожидается заполнения 
                Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать 
                Tenured в компактном состоянии
            </p>    
        </li>
        <li><b>G1 GC</b> - память разбивается на множество регионов одинакового размера. Размер этих регионов зависит от общего размера 
            кучи и по умолчанию выбирается так, чтобы их было не больше 2048, обычно получается от 1 до 32 МБ. Разделение регионов на Eden, 
            Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд и даже могут менять свою 
            принадлежность к тому или иному поколению
        </li>
    </ul>
</details>
<details><summary>Когда объект становится пригодным для удаления сборщиком мусора?</summary>
    <p>Когда на объект в памяти нет ссылок</p>
</details>
<details><summary>Типы ссылок объектов?</summary>
    <a href="https://habr.com/ru/post/549176/">Управление памятью Java</a>
    <p>Разница между типами ссылок заключается в том, что объекты в куче, на которые они ссылаются, имеют право на сборку мусора по различным критериям</p>
    <ol>Типы:
        <li><b>Сильная ссылка</b> - объект в куче не удаляется сборщиком мусора, пока на него указывает сильная ссылка или если он явно доступен через цепочку сильных ссылок</li>
        <li><b>Слабая ссылка</b> -  слабая ссылка на объект из кучи, скорее всего, не сохранится после следующего процесса сборки мусора<br>
            WeakReference&lt;StringBuilder&gt; reference = new WeakReference&lt;&gt;(new StringBuilder());<br>
            Хорошим вариантом использования слабых ссылок являются сценарии кеширования
        </li>
        <li><b>Мягкая ссылка</b> - будут собираться сборщиком мусора только тогда, когда вашему приложению не хватает памяти. 
            Следовательно, пока нет критической необходимости в освобождении некоторого места, сборщик мусора не будет касаться 
            легко доступных объектов. Java гарантирует, что все объекты, на которые имеются мягкие ссылки, будут очищены до того, 
            как будет выдано исключение OutOfMemoryError<br>
            SoftReference&lt;StringBuilder&gt; reference = new SoftReference&lt;&gt;(new StringBuilder());
        </li>
        <li><b>Фантомная ссылка</b> - будет выполнена попытка утилизации данного объекта при сборке мусора. Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная
            ссылка или данная фантомная ссылка не очищена с помощью вызова метода clear(). Так же стоит заметить, что метод get() 
            фантомной ссылки всегда возвращает null
            PhantomReference&lt;StringBuilder&gt; reference = new PhantomReference&lt;&gt;(new StringBuilder());
        </li>
    </ol>
</details>
<details><summary>Как запустить сборку мусора из кода Java?</summary>
    <a href="https://www.theserverside.com/video/5-ways-to-force-Java-garbage-collection">5 ways to force Java garbage collection</a><br>
    <ul>методы
        <li>System.gc()</li>
        <li>Runtime.getRuntime().gc()</li>
    </ul>
</details>