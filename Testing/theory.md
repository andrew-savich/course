<details><summary>Testing pyramid</summary>
    <a href="https://habr.com/ru/post/672484/">Подробнее про пирамиду тестирования</a><br>
    <p><b>Пирамида тестирования (уровни тестирования)</b> - это группировка тестов по уровню детализации и их назначению. 
        Эту абстракцию придумал Майк Кон и описал в книге «Scrum: гибкая разработка ПО» (Succeeding With Agile. 
        Software Development Using Scrum).
    </p>
    <p><b>Пирамида тестирования</b> — один из способов обеспечения качества ПО, визуализация, которая помогает группировать 
        тесты по типу их назначения. Так же, позволяет согласовать правила написания тестов, разделения их на типы, 
        обозначить основной фокус тестирования в каждой из групп
    </p>
    <ol>Для чего нужна
        <li>Экономия времени и ресурсов в процессах обеспечения качества</li>
        <li>Сократить количество сложных кейсов тестирования</li>
        <li>Группировка и типизация тестов</li>
        <li>Снижение рисков возникновения критических дефектов ПО</li>
        <li>Формализация требований к кодовой базе: code coverage, тестовые планы</li>
        <li>Автоматизация рутинных и частых операций</li>
        <li>Изоляция ресурсов в зависимости от вида тестирования</li>
    </ol>
    <ul>уровни:
        <li>модульное тестирование (юнит)</li>
        <li>интеграционное тестирование</li>
        <li>системное тестирования</li>
        <li>приемочное тестирование</li>
    </ul>
    <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/a60/ad7/201/a60ad72010e91be3d897c9e4b02eccaa.png" width="25%">
    <img src="https://tlroadmap.io/assets/img/test-pyramid.10dbb67f.png" width="50%"><br>
    <ul>Пирамида тестирования, в том числе, помогает наглядно объяснить причины, почему количество Unit тестов должно быть 
        больше чем интеграционных. Части треугольника закрашенные разными цветами подразумевают количество необходимых 
        тестов данной категории, чем больше площадь, тем больше тестов. Чем ниже находятся на пирамиде тесты, тем:
        <li>проще и быстрее они разрабатываются</li>
        <li>ниже затраты на поддержку тестов</li>
        <li>быстрее скорость запуска атомарного теста</li>
        <li>выше уровень изоляции компонент между собой</li>
        <li>меньше нужно денег на содержание инфраструктуры для запуска этих тестов</li>
        <li>ниже уровень необходимой квалификации того, кто эти тесты может разрабатывать</li>
    </ul>
</details>
<details><summary>Основные понятия и классификация</summary>
    <h4>1. Классификация тестирования по целям</h4>
    <p>Каждый программный продукт должен выполнять одну или несколько ключевых задач</p>
    <ol>Анализ ПО с позиции его ключевых или вспомогательных функций определяет тип тестирования:
        <li><b>Функциональное</b> - направлено на проверку того, какие основыне функции ПО реализованы, и того, 
            насколько верно они реализованы
        </li>
        <li><b>Нефункциональное</b> - проверка корректности работы нефункциональных требований. Оценивается, как программный продукт работает
            <ul>
                <li><d>Тестирование производительности</d> - работа ПО под определённой нагрузкой</li>
                <li><d>Тестирование пользовательского интерфейса</d> - удобство пользователя при взаимодействии с разными параметрами интерфейса (кнопки, цвета, выравнивание и т. д.)</li>
                <li><d>Тестирование UX</d> - правильность логики использования программного продукта</li>
                <li><d>Тестирование защищенности</d> - определение безопасности ПО: защищено ли оно от атак хакеров, несанкционированного доступа к данным и т. д.</li>
                <li><d>Инсталляционное тестирование</d> - оценка вероятности возникновения проблем при установке, удалении, а также обновлении ПО</li>
                <li><d>Тестирование совместимости</d> - тестирование работы программного продукта в определённом окружении</li>
                <li><d>Тестирование надежности</d> - работа программы при длительной средней ожидаемой нагрузке</li>
                <li><d>Тестирование локализации</d> - оценка правильности версии программного продукта (языковой и культурный аспекты)</li>
            </ul>
        </li>
    </ol>
    <h4>2. Степень автоматизации</h4>
    <ol>В зависимости от того, используют ли тестировщики дополнительные программные средства для тестирования приложений или программ, тестирование бывает:
        <li><b>Мануальное (ручное)</b> - без использования дополнительных программных средств, т. е. «вручную»</li>
        <li><b>Автоматизированное</b> - с использованием программных средств</li>
    </ol>
    <ul>Плюсы ручного тестирования:
        <li><b>Отчет тестировщика</b> - это первый отзыв потенциального клиента, который позволит понять, насколько продукт удобен для конечного пользователя</li>
        <li><b>Обратная связь по UI</b> - Протестировать общий дизайн приложения и выявить его недостатки представляется возможным только при ручном тестировании</li>
        <li><b>Стоимость</b> - Когда речь идет о небольшом проекте, внедрять ручное тестирование всегда менее затратно, чем автоматизацию</li>
        <li><b>Гибкость</b> - Тестирование несущественных изменений происходит сразу, без затрат на написание кода.
            Это особенно важно при быстром внедрении новой функциональности, когда нужно быть уверенным в ее корректной работе
        </li>
        <li><b>Исследовательское тестирование и возможность импровизации</b> - позволяет проверить потенциал приложения в нетипичных сценариях и обнаружить существенные дефекты в короткие сроки</li>
    </ul>
    <ul>Минусы ручного тестирования:
        <li><b>Человеческий фактор</b> - Часть ошибок продукта может быть пропущена, а некоторые результаты проверки могут оказаться субъективными</li>
        <li><b>Трудозатраты и продолжительность</b> - Серия автоматизированных тестов позволяет протестировать программное обеспечение значительно быстрее</li>
        <li><b>Отсутствие возможности моделирования большой нагрузки</b> - При ручном тестировании невозможно смоделировать большое количество пользователей</li>
    </ul>
    <ul>Плюсы автоматизированного тестирования:
        <li><b>Нагрузка на приложение</b> - Когда используется автоматизированное тестирование, становится возможным моделирование большой нагрузки, которая приближена к реальной ситуации.</li>
        <li><b>Временной фактор</b> - </li>
        <li><b>Повторяемость</b> - Код автотестов может быть использован неоднократно, особенно при внедрении новой функциональности</li>
    </ul>
    <ul>Минусы автоматизированного тестирования:
        <li><b>Отсутствие обратной связи</b> - Автоматизированное тестирование не способно предоставить обратную связь относительно качества продукта – оно лишь выполняет запрограммированные сценарии</li>
        <li><b>Отсутствие тестирования глазами пользователя</b> - Иногда в приложении остаются ошибки, которые могут быть не покрыты автотестами</li>
        <li><b>Отсутствие возможности тестирования цвета, дизайна и эргономики</b> - Этот пункт не является первостепенным, но может значительно повлиять на качество продукта</li>
        <li><b>Надежность</b> - Автоматизированные тесты могут упасть по многим причинам, например, при большой загруженности тестовой машины или при проблемах с сетью</li>
        <li><b>Стоимость</b> - Для небольших проектов инструменты автоматизированного тестирования могут оказаться достаточно затратными, поэтому более рационально их использовать для долгосрочных проектов</li>
    </ul>
    <h4>3. Позитивность сценария</h4>
    <ol>
        <li><b>Позитивная проверка</b> - оценка ожидаемого поведения. Это тестирование проводится в первую очередь, ведь позволяет определить корректность работы программы</li>
        <li><b>Негативная</b> - определение устойчивости системы в нестандартной ситуации. Например, неожиданный сценарий взаимодействия пользователя с интерфейсом</li>
        <li></li>
    </ol>
    <h4>4. Доступ к коду программного продукта</h4>
    <ol>
        <li><b>Тестирование «белого ящика»</b> - с доступом к коду</li>
        <li><b>Тестирование «черного ящика»</b> - без доступа к коду продукта</li>
        <li><b>Тестирование «серого ящика»</b> - тестировщик не работает с кодом программного продукта, но он знаком с внутренней структурой программы и взаимодействием между компонентами</li>
    </ol>
    <h4>5. Уровень</h4>
        <ol>
            <li><b>Модульное / юнит-тестирование</b> - проверка корректной работы отдельных единиц ПО, модулей. Этот вид тестирования могут выполнять сами разработчики</li>
            <li><b>Интеграционное тестирование</b> - проверка взаимодействия между несколькими единицами ПО</li>
            <li><b>Системное</b> - проверка работы приложения целиком</li>
            <li><b>Приёмочное</b> - оценка соответствия заявленным требованиям к программному продукту</li>
        </ol>
    <h4>6. Исполнитель</h4>
    <ol>
        <li><b>Альфа-тестирование</b> - проверка программного продукта на поздней стадии разработки. Проводится разработчиками или тестировщиками</li>
        <li><b>Бета-тестирование</b> -  оценка ПО перед выходом на рынок в фокус-группе или добровольцами. Отзывы собираются, анализируются и учитываются при внесении правок</li>
    </ol>
    <h4>7. Формальность</h4>
    <ol>
        <li><b>Тестирование по тестам</b> - использование написанных заранее тест-кейсов</li>
        <li><b>Исследовательское тестирование</b> - одновременная разработка тестов и их использование</li>
        <li><b>Свободное тестирование</b> - проверка качества без разработки тестов и написания документации. Основывается на интуиции и опыте тестировщика</li>
    </ol>
    <h4>8. Важность</h4>
    <ol>
        <li><b>Дымовое тестирование</b> - проверка самой важной функциональности программного продукта</li>
        <li><b>Тестирование критического пути</b> - проверка функциональности, используемой типичными пользователями в повседневной деятельности</li>
        <li><b>Расширенное тестирование</b> - проверка всей заявленной функциональности</li>
    </ol>
</details>

<details><summary>Принципы Unit тестирования:</summary>
    <h4>TDD — Test Driven Development</h4>
    <p>Методология разработки ПО, которая основывается на повторении коротких
        циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется программный код, 
        который реализует желаемое поведение системы и позволит пройти написанный тест
    </p>
    <p>Философия разработки на основе тестов заключается в том, что ваши тесты являются спецификацией того, как ваша программа 
        должна вести себя. Если вы рассматриваете свой набор тестов как обязательную часть процесса сборки, если ваши тесты не проходят, 
        программа не собирается, потому что она неверна. Конечно, ограничение заключается в том, что правильность вашей программы 
        определена только как полнота ваших тестов. Тем не менее, исследования показали, что разработка, основанная на тестировании, 
        может привести к снижению ошибок на 40-80% в производстве
    </p>
    <h4>BDD — Behaviour Driven Development</h4>
    <p> это разработка, основанная на описании поведения. Определенный человек(или люди) пишет описания вида "я как пользователь 
        хочу когда нажали кнопку пуск тогда показывалось меню как на картинке" (там есть специально выделенные ключевые слова). 
        Программисты давно написали специальные тулы, которые подобные описания переводят в тесты (иногда совсем прозрачно для программиста). 
        А дальше классическая разработка с тестами.
    </p>
    <p>BDD предполагает описание тестировщиком или аналитиком пользовательских сценариев на естественном языке или на языке бизнеса</p>
    <p>Пример:<br>
        Имея счет с деньгами<<br>
        И валидную карточку<br>
        И банкомат с наличными<br>
        Когда клиент запрашивает наличные<br>
        Тогда убедиться, что со счета было списание<br>
        И убедиться, что наличные выданы<br>
        И убедиться, что карточка возвращена<br>
    </p>
    <ul>Приемущества:
        <li>Тесты читаемые для не программистов</li>
        <li>Их легко изменять</li>
        <li>Их может писать product owner или другие заинтересованные лица</li>
        <li>Результаты выполнения тестов более "человечные"</li>
        <li>Тесты не зависят от целевого языка программирования. Миграция на другой язык сильно упрощается</li>
    </ul>
    <h4>FDD — Features Driven Development</h4>
    <p>Разработка реального, работающего программного обеспечения систематически, в поставленные сроки</p>
    <p>основной упор на коротких итерациях, каждая из которых служит для проработки определенной части функциональности системы. Согласно FDD, одна итерация длится две недели</p>
    <ul>
        <li>разработка общей модели</li>
        <li>составление списка требуемых свойств системы</li>
        <li>планирование работы над каждым свойством</li>
        <li>проектирование каждого свойства</li>
        <li>конструирование каждого свойства</li>
    </ul>
    <h4>MDD — Model Driven Development</h4>
    <p>Стиль разработки программного обеспечения, когда модели становятся основными артефактами разработки, из которых генерируется код и другие артефакты</p>
    <p>Вся суть разработки сводится к построению необходимых диаграмм, из которых впоследствии мы генерируем рабочий код проекта</p>
    <ul>
        <li>cначала разрабатывается модель предметной области проектируемого приложения, полностью независимая от имплементирующей технологии</li>
        <li>затем она трансформируется специальным инструментом в платформо-зависимую модель</li>
        <li>наконец, она переводится в исходный код на соответствующем языке программирования</li>
    </ul>
    <h4>PDD — Panic Driven Development</h4>
    <p><b>Новые задачи приоритетнее старых.</b> Всякий раз, когда в середине спринта появляется новая проблема, она имеет 
        приоритет над любой запланированной работой. Новое всегда лучше и имеет более высокий приорите
    </p>
    <p><b>Тесты должны писаться в конце.</b> После того, как исправление внедрено, тесты могут быть запланированы как задача, 
        которая будет сделана в будущем. Тесты полезны, но не являются приоритетными. Вы можете позаботиться о них позже.
    </p>
    <ul>Плюсы
        <li>высокая скорость разработки</li>
        <li>дешево</li>
        <li>заказчики счастливы, что наконец-то нашли толковых разработчиков</li>
    </ul>
    <ul>Минусы
        <li>все плюсы разобьются о технический долг и сложность проекта</li>
    </ul>
</details>

<details><summary>Ручное vs Автоматизированное</summary>
    <p></p>
</details>

<details><summary>Testing tools</summary>
    <h4>1. JUnit</h4>
    <p>Фреймворк для модульного тестирования программного обеспечения на языке Java.</p>
    <h4>2. Mockito</h4>
    <p>Mocking является одним из основных методов современного модульного тестирования, поскольку он позволяет тестировать код изолированно без каких-либо зависимостей</p>
    <h4>3. TestNG</h4>
    <p>Аналог JUnit</p>
    <h4>4. REST Assured</h4>
    <p> это библиотека Java для тестирования API RESTful. Он широко используется для тестирования веб-приложений на базе JSON и XML.
        Кроме того, он полностью поддерживает все методы, включая GET, PUT, POST, PATCH и DELETE.
    </p>
</details>

<details><summary>Unit Testing overview</summary>
    <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Модульное тестирование</a><br>
    <p><b>Модульное тестирование, или юнит-тестирование (англ. unit testing)</b> - процесс в программировании, позволяющий 
        проверить на корректность отдельные модули исходного кода программы
    </p>
    <p>Цель модульного тестирования — изолировать отдельные части программы и показать, что по отдельности эти части работоспособны.</p>
    <p>Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро 
        проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных 
        местах программы, а также облегчает обнаружение и устранение таких ошибок
    </p>
    <ul>Инструменты юнит тестирования
        <li><b>JUnit</b> - </li>
        <li><b>TestNG</b> - </li>
    </ul>
    <ul>Преимущества юнит-тестов
        <li><b>Поощрение изменений</b> - позволяет программистам проводить рефакторинг, будучи уверенными, что модуль по-прежнему 
            работает корректно (регрессионное тестирование). Это поощряет программистов к изменениям кода, поскольку достаточно 
            легко проверить, что код работает и после изменений.
        </li>
        <li><b>Упрощение интеграции</b> - помогает устранить сомнения по поводу отдельных модулей и может быть использовано 
            для подхода к тестированию «снизу вверх»: сначала тестируя отдельные части программы, а затем программу в целом
        </li>
        <li><b>Документирование кода</b> - Модульные тесты можно рассматривать как «живой документ» для тестируемого класса.
            Клиенты, которые не знают, как использовать данный класс, могут использовать юнит-тест в качестве примера.
        </li>
        <li><b>Отделение интерфейса от реализации</b> - некоторые классы могут использовать другие классы, тестирование 
            отдельного класса часто распространяется на связанные с ним. Например, класс пользуется базой данных; в ходе 
            написания теста программист обнаруживает, что тесту приходится взаимодействовать с базой. Это ошибка, поскольку
            тест не должен выходить за границу класса. В результате разработчик абстрагируется от соединения с базой данных
            и реализует этот интерфейс, используя свой собственный mock-объект. Это приводит к менее связанному коду, 
            минимизируя зависимости в системе.
        </li>
    </ul>
</details>

<details><summary>Testing interactions. Mocks. Mockito</summary>
    <a href="https://habr.com/ru/post/577424/">Когда использовать mocks в юнит-тестировании</a><br>
    <p><b>Тестовый двойник</b> - это всеобъемлющий термин, который описывает все виды фальшивых (fake) зависимостей, 
        непригодных к использованию в конечном продукте (non-production-ready), в тестах. Такая зависимость выглядит и 
        ведет себя как ее аналог, предназначенный для production, но на самом деле является упрощенной версией, которая 
        снижает сложность и облегчает тестирование.
    </p>
    <ol>5 видов тестовых двойников:
        <li>Пустышка (dummy)</li>
        <li>Стаб (stub)</li>
        <li>Шпион (spy)</li>
        <li>Мок (mock)</li>
        <li>Фейк (fake)</li>
    </ol>
    <p><b>Mock-объект</b> - представляет собой конкретную фиктивную реализацию интерфейса, предназначенную исключительно
        для тестирования взаимодействия и относительно которого высказывается утверждение
    </p>
    <p><b>Mockito</b> — фреймворк для работы с заглушками</p>
    <ul>Способы создания mocks:
        <li>Анотации:<br>
            @Mock<br>
            ICalculator mcalc;
        </li>
        <li>Методом:<br>
            ICalculator mcalc = mock(ICalculator.class);
        </li>
    </ul>
    <ul>Методы:
        <li>Определение поведения - when(mock).thenReturn(value)</li>
        <li><ul>Подсчет количества вызовов - atLeast, atLeastOnce, atMost, times, never
                <li>atLeast(int min) - не меньше min вызовов</li>
                <li>atLeastOnce() - хотя бы один вызов;</li>
                <li>atMost(int max) - не более max вызовов</li>
                <li>times(int cnt) - cnt вызовов</li>
                <li>never() - вызовов не было</li>
            </ul>
        </li>
        <li>Обработка исключений - when(mock).thenThrow()</li>
        <li>Проверка вызова метода с задержкой, timeout. Фреймворк Mockito позволяет выполнить проверку вызова определенного 
            метода в течение заданного в timeout времени. Задержка времени определяется в милисекундах.
        </li>
    </ul>
</details>

<details><summary>Mockito</summary>
    <p><b>Mockito</b>фреймворк для тестирования приложений, который позволяет легко и быстро подменять реальные объекты 
        программы «пустышками». Такие фиктивные объекты часто называют «моками»
    </p>
    <p>Предназначен для подмены логики компанента/зависимости</p>
    <p>Суть Mockito в том, чтобы подсунуть нам не наш экземпляр, а его наследника, который может иметь какие-либо необходимые модификации.<br>
        Mockito основан на проксировании. Есть библиотеки, занимающиеся тем же, но основанные не на проксировании, а 
        на изменении байт-кода. Примером такой библиотеки может служить PowerMock с лицензией Apache-2.0 License.        
    </p>
</details>
<details><summary>PowerMock</summary>
    <p>Это расширение Mockito использующее Java Reflection API, которое используется для подмены логики статических и приватных методов</p>
    <p>Если в проекте используется PowerMockito - признак плохой архитектуры приложения. Желательно использовать в
        легаси приложениях где нет возможности изменения кода
    </p>
</details>

<details><summary>FIRST</summary>
    <p>5 принципов качественного написания тестов</p>
    <ul>
        <li><b>Быстрота (Fast)</b> - Тесты должны выполняться быстро.</li>
        <li><b>Независимость (Independent)</b> - Результаты выполнения одного теста не должны быть входными данными для другого. 
            Все тесты должны выполняться в произвольном порядке, поскольку в противном случае при сбое одного теста каскадно 
            “накроется” выполнение целой группы тестов
        </li>
        <li><b>Повторяемость (Repeatable)</b> - Тесты должны давать одинаковые результаты не зависимо от среды выполнения. 
            Результаты не должны зависеть от того, выполняются ли они на вашем локальном компьютере, на компьютере 
            соседа или же на билд-сервере
        </li>
        <li><b>Очевидность (Self-Validating)</b> - Тест либо прошел, либо не прошел и это должно быть легко понятно любому 
            разработчику.  Не нужно заставлять людей читать логи только для того, чтобы определить прошел тест успешно или нет
        </li>
        <li><b>Своевременность (Timely)</b> - Тесты должны создаваться своевременно. Несвоевременность написания тестов является 
            главной причиной того, что они откладываются на потом, а это “потом” так никогда и не наступает. Даже если вы и 
            не будете писать тесты перед кодом (хотя этот вариант уже доказал свою жизнеспособность) их нужно писать как минимум 
            параллельно с кодом
        </li>
    </ul>
</details>