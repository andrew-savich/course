<details><summary>Queue</summary>
    <p><b>Queue</b> - интерфейс очереди в java, работающий по принципу первый вошел - первый вышел (FIFO)</p>
    <ul>Описывает методы:
        <li><b>boolean add(E e)</b> - вставляет элемент, если успешно то возвращает true, иначе бросает IllegalStateException</li>
        <li><b>E element()</b> - возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>boolean offer(E obj)</b> - добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false</li>
        <li><b>E peek()</b> - возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E poll()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E remove()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
    </ul>
</details>
<details><summary>Deque</summary>
    <p>Deque расширяет интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO</p>
    <ul>Методы:
        <li><b>void addFirst(E obj)</b> - добавляет элемент в начало очереди</li>
        <li><b>void addLast(E obj)</b> - добавляет элемент obj в конец очереди</li>
        <li><b>E getFirst()</b> - возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>E getLast()</b> - возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>boolean offerFirst(E obj)</b> - добавляет элемент obj в самое начало очереди. Если элемент удачно добавлен, возвращает true, иначе - false</li>
        <li><b>boolean offerLast(E obj)</b> - добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false</li>
        <li><b>E peekFirst()</b> - возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E peekLast()</b> - возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E pollFirst()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E pollLast()</b> - возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E pop()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>void push(E element)</b> - добавляет элемент в самое начало очереди</li>
        <li><b>E removeFirst()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>E removeLast()</b> - возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>boolean removeFirstOccurrence(Object obj)</b> - удаляет первый встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false</li>
        <li><b>boolean removeLastOccurrence(Object obj)</b> - удаляет последний встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false</li>
    </ul>
</details>
<details><summary>ArrayDeque</summary>
    <p>Класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса AbstractCollection и применяя интерфейс Deque</p>
    <p>Эта коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и хранение null</p>
    <ol>Особенности:
        <li>Непотокобезопасная</li>
        <li>не поддерживает хранение null</li>
        <li>Работает значительно быстрее, чем синхронизированный Stack</li>
        <li>Является более быстрой очередью, чем LinkedList, из-за лучшей локальности ссылки</li>
        <li>Большинство операций имеют постоянную временную сложность</li>
        <li>Итератор, возвращаемый ArrayDeque, является fail-fast (отказоустойчивым)</li>
        <li>ArrayDeque автоматически удваивает размер массива, когда указатель начала и хвоста встречаются друг с другом при добавлении элемента</li>
    </ol>
    <ul>Конструкторы:
        <li><b>ArrayDeque()</b> - создает пустую очередь</li>
        <li><b>ArrayDeque(Collection&lt;? extends E&gt;	 col)</b> - создает очередь, наполненную элементами из коллекции col</li>
        <li><b>ArrayDeque(int capacity)</b> - создает очередь с начальной емкостью capacity. Если мы явно не указываем начальную емкость, то емкость по умолчанию будет равна 16</li>
    </ul>
    <p>Работа как Стек: если мы используем методы для добавлени <b>push</b>, а для извлечения <b>pop</b> то ArrayDeque будет работать как стек:<br>
        когда мы извлекаем элемент, он устанавливает элемент в позиции head как нулевой, чтобы элемент мог быть удален сборщиком мусора, а затем перемещает указатель head на единицу назад<br>
        <img src="https://www.baeldung.com/wp-content/uploads/2017/11/Stack.jpg" >
    </p>
    <p>Работа как очередь: Когда мы добавляем элемент с помощью метода <b>offer</b>, он перемещает хвостовой указатель на единицу. В то время как, когда получаем элемент
        методом <b>poll</b>, он устанавливает для элемента в позиции head значение null, чтобы элемент мог быть удален сборщиком мусора, а затем перемещает указатель head<br>
        <img src="https://www.baeldung.com/wp-content/uploads/2017/11/Queue.jpg" > 
    </p>
</details>
<details><summary>PriorityQueue</summary>
    <p>Класс PriorityQueue расширяет класс AbstractQueue и реализует интерфейс Queue. Он служит для создания очереди по приоритетам на основании компаратора очереди</p>
    <ul>Особенности:
        <li>не допускает null</li>
        <li>не можем создать PriorityQueue из non-comparable объектов</li>
        <li>Неограниченная, расширяемая очередь</li>
        <li>Голова — это наименьший элемент по отношению к указанному порядку</li>
        <li>Поскольку PriorityQueue не является потокобезопасным, Java предоставляет класс PriorityBlockingQueue, который реализует интерфейс BlockingQueue для использования в многопоточной среде Java</li>
        <li>Операции извлечения из очереди опрос, удаление, просмотр и доступ к элементу в начале очереди</li>
        <li>Он обеспечивает время O (log (n)) для методов добавления и опроса</li>
        <li>Он наследует методы класса AbstractQueue, AbstractCollection, Collection и Object</li>
    </ul>
</details>
<details><summary>ArrayBlockQueue</summary>
    <p></p>
</details>
<details><summary>Работа Map? В каких ситуациях использовать?</summary>
    <p><b>Map</b> - интерфейс представления (карты) который хранит данные в виде пар ключ-значение. Он не является частью java.util.collections,
        но очень тесно связан. На его основе построены коллекции типа Set
    </p>
    <ul>Особенности:
        <li>Map не может содержать повторяющиеся ключи</li>
        <li>Каждому ключу может соответствовать только одно значение</li>
        <li>Некотороыйе реализации поддерживают в качестве ключа null, такие как HashMap и LinkedHashMap</li>
    </ul>
</details>
<details><summary>HashMap</summary>
    <p><b>HashMap</b> - основан на хэш-таблицах, реализует интерфейс Map. Ключи и значения могут быть ссылочных типов, в том числе и null. 
        Данная реализация не дает гарантий относительно порядка элементов с течением времени
    </p>
    <ul>Поля HashMap:
        <li><b>table</b> - Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений</li>
        <li><b>loadFactor</b> - Коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных</li>
        <li><b>threshold</b> - Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (capacity * loadFactor)</li>
        <li><b>size</b> - Количество элементов</li> 
    </ul>
</details>
<details><summary>LinkedHashMap</summary>
    <p><b>LinkedHashMap</b> основана на хеш таблице и связанном списке. Расширяет класс HashMap. Добавляя свои свойства:</br>
        header - «голова» двусвязного списка; accessOrder указывает каким образом будет осуществляться доступ к элементам при использовании итератора
    </p>
    <p>Порядок вставки сохраняется за счет того, что в Entry храняться ссылки на следующий и предыдущий элементы (before, after)</p>
    <p>LinkedHashMap имеет чуть хуже производительность чем HashMap, за счет накладных расходов</p>
</details>
<details><summary>TreeMap</summary>
    <p><b>TreeMap</b> - реализация map, которая сортирует свои записи по ключу с использованием компаратора</p>
    
</details>
<details><summary>HashMap vs LinckedMap</summary>
    <p>HashMap хороша как реализация карты общего назначения, обеспечивающая быстрое хранение и поиск. Однако она хуже из-за хаотичного и беспорядочного расположения записей</p>
    <p>Это приводит к тому, что он плохо работает в сценариях с большим количеством итераций, поскольку вся емкость базового массива влияет на обход, а не только на количество записей</p>
    <p>LinkedHashMap обладает хорошими атрибутами хэш-карт и упорядочивает записи. Он работает лучше при большом количестве итераций, поскольку учитывается только количество записей независимо от емкости</p>
</details>
<details><summary>Hashtable vs HashMap</summary>
    <p>Hashtable - старая реализация структуры данных хэш-таблицы в Java</p>
    <ul>Особенности Hashtable:
        <li>Потокобезопасность</li>
        <li>null не может быть ключем</li>
        <li>Хуже производетельность из-за потокобезопастности</li>
    </ul>
</details>