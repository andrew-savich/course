<details><summary>Queue</summary>
    <p><b>Queue</b> - интерфейс очереди в java, работающий по принципу первый вошел - первый вышел (FIFO)</p>
    <ul>Описывает методы:
        <li><b>boolean add(E e)</b> - вставляет элемент, если успешно то возвращает true, иначе бросает IllegalStateException</li>
        <li><b>E element()</b> - возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>boolean offer(E obj)</b> - добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false</li>
        <li><b>E peek()</b> - возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E poll()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E remove()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
    </ul>
</details>
<details><summary>Deque</summary>
    <p>Deque расширяет интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO</p>
    <ul>Методы:
        <li><b>void addFirst(E obj)</b> - добавляет элемент в начало очереди</li>
        <li><b>void addLast(E obj)</b> - добавляет элемент obj в конец очереди</li>
        <li><b>E getFirst()</b> - возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>E getLast()</b> - возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>boolean offerFirst(E obj)</b> - добавляет элемент obj в самое начало очереди. Если элемент удачно добавлен, возвращает true, иначе - false</li>
        <li><b>boolean offerLast(E obj)</b> - добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false</li>
        <li><b>E peekFirst()</b> - возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E peekLast()</b> - возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E pollFirst()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E pollLast()</b> - возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение null</li>
        <li><b>E pop()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>void push(E element)</b> - добавляет элемент в самое начало очереди</li>
        <li><b>E removeFirst()</b> - возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>E removeLast()</b> - возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение NoSuchElementException</li>
        <li><b>boolean removeFirstOccurrence(Object obj)</b> - удаляет первый встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false</li>
        <li><b>boolean removeLastOccurrence(Object obj)</b> - удаляет последний встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false</li>
    </ul>
</details>
<details><summary>PriorityQueue</summary>
    <p>Класс PriorityQueue расширяет класс AbstractQueue и реализует интерфейс Queue. Он служит для создания очереди по приоритетам на основании компаратора очереди</p>
    <ul>Особенности:
        <li>не допускает null</li>
        <li>не можем создать PriorityQueue из non-comparable объектов</li>
        <li>Неограниченная, расширяемая очередь</li>
        <li>Голова — это наименьший элемент по отношению к указанному порядку</li>
        <li>Поскольку PriorityQueue не является потокобезопасным, Java предоставляет класс PriorityBlockingQueue, который реализует интерфейс BlockingQueue для использования в многопоточной среде Java</li>
        <li>Операции извлечения из очереди опрос, удаление, просмотр и доступ к элементу в начале очереди</li>
        <li>Он обеспечивает время O (log (n)) для методов добавления и опроса</li>
        <li>Он наследует методы класса AbstractQueue, AbstractCollection, Collection и Object</li>
    </ul>
</details>
<details><summary>ArrayBlockQueue</summary>
    <p></p>
</details>
<details><summary>Работа Map? В каких ситуациях использовать?</summary>
    <p><b>Map</b> - интерфейс представления (карты) который хранит данные в виде пар ключ-значение. Он не является частью java.util.collections,
        но очень тесно связан. На его основе построены коллекции типа Set
    </p>
    <ul>Особенности:
        <li>Map не может содержать повторяющиеся ключи</li>
        <li>Каждому ключу может соответствовать только одно значение</li>
        <li>Некотороыйе реализации поддерживают в качестве ключа null, такие как HashMap и LinkedHashMap</li>
    </ul>
</details>
<details><summary>HashMap</summary>
    <p><b>HashMap</b> - основан на хэш-таблицах, реализует интерфейс Map. Ключи и значения могут быть ссылочных типов, в том числе и null. 
        Данная реализация не дает гарантий относительно порядка элементов с течением времени
    </p>
    <ul>Поля HashMap:
        <li><b>table</b> - Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений</li>
        <li><b>loadFactor</b> - Коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных</li>
        <li><b>threshold</b> - Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (capacity * loadFactor)</li>
        <li><b>size</b> - Количество элементов</li> 
    </ul>
</details>
<details><summary>LinkedHashMap</summary>
    <p><b>LinkedHashMap</b> основана на хеш таблице и связанном списке. Расширяет класс HashMap. Добавляя свои свойства:</br>
        header - «голова» двусвязного списка; accessOrder указывает каким образом будет осуществляться доступ к элементам при использовании итератора
    </p>
    <p>Порядок вставки сохраняется за счет того, что в Entry храняться ссылки на следующий и предыдущий элементы (before, after)</p>
    <p>LinkedHashMap имеет чуть хуже производительность чем HashMap, за счет накладных расходов</p>
</details>
<details><summary>TreeMap</summary>
    <p><b>TreeMap</b> - реализация map, которая сортирует свои записи по ключу с использованием компаратора</p>
    
</details>
<details><summary>HashMap vs LinckedMap</summary>
    <p>HashMap хороша как реализация карты общего назначения, обеспечивающая быстрое хранение и поиск. Однако она хуже из-за хаотичного и беспорядочного расположения записей</p>
    <p>Это приводит к тому, что он плохо работает в сценариях с большим количеством итераций, поскольку вся емкость базового массива влияет на обход, а не только на количество записей</p>
    <p>LinkedHashMap обладает хорошими атрибутами хэш-карт и упорядочивает записи. Он работает лучше при большом количестве итераций, поскольку учитывается только количество записей независимо от емкости</p>
</details>
<details><summary>Hashtable vs HashMap</summary>
    <p>Hashtable - старая реализация структуры данных хэш-таблицы в Java</p>
    <ul>Особенности Hashtable:
        <li>Потокобезопасность</li>
        <li>null не может быть ключем</li>
        <li>Хуже производетельность из-за потокобезопастности</li>
    </ul>
</details>