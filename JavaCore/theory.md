##Part1
<details><summary>Принципы ООП</summary>
<b>ООП</b> - методология программирования, при которой взаимодействия в программе осуществляются
    за счёт объектов, которые обладают своими свойствами и поведением, которые описаны
    в классах, экземплярами которых они являются<br>
    <ul>
    Для достижения этого выделяют <b>4 основных принципа ООП</b>:
        <li><b>Абстракция</b> - выделение общийх характеристик объекта</li>
        <li><b>Наследование</b> - процесс, при котором один объект может приобретать св-ва
            другого объекта
        </li>
        <li><b>Инкапсуляциия</b> - принцип, который объеденяет данные и код,
            манипулирующий ими, а так же защищающий от прямого внешнего доступа к ним
        </li>
    <li><b>Полиморрфизм</b> - механизм, при котором используется одно имя метода
        для решения различных но подобных задач<br>
        Концепция полиморфизма: "Один интерфейс множество методов"
    </li>
    </ul>
</details>

<details><summary>Примитивные типы данных</summary>
    <b>Примитивные типы данных</b> представляют собой одиночные значения, хранящиеся в памяти.
    <ul>Примитивные типы данных
        <li>Целочисленные
            <ul>
                <li><b>byte</b> - от -128 до 127, 1 байт (8 бит)</li>
                <li><b>short</b> - от -32768 до 32767, 2 байта (16 бит)</li>
                <li><b>int</b> - от -2147483648 до 2147483647, 4 байта (32 бит)</li>
                <li><b>long</b> - от -9223372036854775808 до 9223372036854775807, 8 байта (64 бит)</li>
            </ul>
        </li>
        <li>С плавающей точкой
            <ul>
                <li><b>float</b> - от 1.4е-045 до 3.4е+ОЗ8, 4 байта (32 бит)</li>
                <li><b>double</b> - от 4.9е-324 до 1.8е+308, 8 байта (64 бит)</li>
            </ul>
        </li>
        <li>Логические
            <ul>
                <li><b>boolean</b> - имеет только 2 значения <b>true</b> и <b>false</b>. 
                    1 байт, т.е. 8 бит (в массивах), 4 байта, т.е. 32 (не в массивах используется int)
                </li>
            </ul>
        </li>
        <li>Символьные
            <ul>
                <li><b>char</b> - от 0 до 65536, 2 байта (16 бит)</li>
            </ul>
        </li>
    </ul>
</details>

<details><summary>Ссылочные типы данных</summary>
    Ссылочные типы данных хранят адрес ячейки(ссылку) памяти, в которой расположен определенный объект.<br>
    Любой класс в Java — это ссылочный тип данных.
</details>

<details><summary>Ссылочные vs Примитивные типы данных</summary>
    <p>В примитивных типах данных значения передаются по значению, т.е.:<br>
    int x = 3;<br>
    int y = x;<br>
    Создается переменная <b>x</b> типа <b>int</b> и ей присваивается значение 3, дальше создается 
    переменная <b>y</b> типа <b>int</b> и ей присвается значение переменной <b>x</b>.
    В дальнейшем переменная <b>x</b> никак не влияет на <b>y</b>. Java копирует значение
    <b>х</b> (3) и помещает эту копию в <b>у</b>.
    Это передача параметра по значению. Вы не записываете одну переменную в другую.
    Значение копируется и присваивается новой переменной.</p>
    <p>В ссылочных типах данных копируется ссылка.<br>
    Object firstObject = new Object();<br>
    Object secondObject = firstObject();<br>
    после этих операций firstObject и secondObject будут ссылаться на одну и ту же ячейку памяти (бъект)
    </p>
    <p>Параметры методов так же преедаются: примитивы - копируется их хначение, ссылочные - 
    копируется их ссылка</p>
</details>

<details><summary>Конструкторы</summary>
    <b>Конструктор</b> - это метод предназанченный для инициализации экземпляра класса.
    Конструктор есть в каждом классе! Если он не объявлен явно, он будет предоставлен по умолчанию.<br>
    <ul>Особенности конструкторов:
        <li>Имя конструктора совпадает с именем его класса и начинается с большой буквы</li>
        <li>Конструктор ни чего не возвращает. void можно не указывать</li>
        <li>У констр. могут быть объявлены с каким-нибудь из модификаторов доступа
            (public, protected, private, или по умолчанию)
        </li>
        <li>Конструкторы можно перегружать</li>
    </ul>
    <ul>Типы конструкторов:
        <li><b>По умолчанию</b></li>
        <li><b>С параметрами</b></li>
        <li><b>Конструктор копирования</b> - входным параметром является объект того же класса</li>
    </ul>
    <p>С помощью конструктора мы задаем минимальное количество полей, которые должны быть проинициализированы,
    при создании объекта. Т.к. в логическом контексте поля класса делятся на:
    <ul>
        <li>Неизменяемые/стандартные (id)</li>
        <li>Те которые нужны для создания экземпляра</li>
        <li>Наполнения, которые мы в процессе будет изменять/задавать</li>
    </ul>
    </p>
</details>

<details><summary>Блоки инициализации</summary>
    <p>Предназначены для инициализации начальных значений
        <ul>бывают:
            <li><b>нестатические</b> - выполняется при каждой инициализации экземпляра класса</li>
            <li><b>статические</b> - выполняются единожды, при первой инициализации экз объекта</li>
        </ul>
    </p>
</details>

<details><summary>Типы классов Java</summary>
    <ul>Классы в Java бывают:
        <li><b>Обычные</b> - те классы, которые мы используем/создаем чаще всего</li>
        <li><b>Вложенные (Nested)</b> - классы которые определены внутри других классов, и используются для обслуживания
                своих внешних классов:
            <ul>
                <li><details><summary><b>Статические вложенные (Static nested)</b></summary>
                        <p>Используются тогда, когда нам нужна логическая связь, между внешним классом и
                            вложенным классом. Кроме этого экземпляр вложенного класса может существовать без экземпляра
                            своего внешнего класса
                        </p>
                    </details>
                </li>
                <li>
                    <b>Внутренние (Inner)</b>
                    <ul>
                        <li><details><summary><b>Внутренние (Inner)</b></summary>
                            <p>Используются тогда, когда нам нужна логическая связь, между внешним классом и
                                вложенным классом, и кроме этого, нужна жёсткая привязанность экземпляра внутреннего класса
                                к экземпляру внешнего класса</p>
                            </details>
                        </li>
                        <li><details><summary><b>Анонимные (Anonymous)</b></summary>
                                <p>
                                    <ul>Используются, если/преимущества:
                                        <li>нам нужно использовать класс только один раз</li>
                                        <li>тело класса является очень коротким</li>
                                        <li>класс используется в месте его создания или сразу после него</li>
                                        <li>имя класса не важно и не облегчает понимание кода</li>
                                    </ul>
                                </p>
                            </details>
                        </li>
                        <li><b>Локальные (Local)</b> - используются только для обслуживания того блока кода, где они объявлены
                            <ul>особенности
                                <li>Доступ к effective-final (final переменные и переменные которые не изменяют своё значение после инициализации)
                                    локальным переменным того блока кода, в котором этот лок. класс объявлен</li>
                                <li>Если лок. класс описан не в статическом методе, то будет иметь доступ к полям внешнего класса</li>
                                <li>Если лок. класс описан в статическом методе, то будет иметь доступ к статическим полям внешнего класса</li>
                                <li>Запрещено объявлять статические переменные (только статические финальные)</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <img src="https://cdn.javarush.ru/images/article/3381c131-b7a8-48e5-948c-e84990ef12d6/800.webp"><br>
    <a href="https://habr.com/ru/post/439648/">Внутренние и вложенные классы java. Часть 1</a>
</details>

<details><summary>Абстрактные классы</summary>
    <p><b>Абстрактный класс</b> - это класс, который имеет один или более абстрактных методов
    (метод без реализации, который должны реализовать наследники этого класса).</p>
    <p>Нельзя создовать экземпляры абстрактного класса</p>
    <p>Абстрактные классы должны помечаться словом 'abstract'</p>
</details>

<details><summary>Интерфейсы</summary>
    <p><b>Интерфейс</b> — это ссылочный тип в Java. Он схож с классом. Это совокупность 
    абстрактных методов. Класс реализует интерфейс, таким образом наследуя 
    абстрактные методы интерфейса.</p>
    <p>Интерфейсы могут иметь методы с реализацией</p>
    <ul><b>может содержать:</b>
        <li>константы (неявно всегда являются модификаторами public, static и final)</li>
        <li>обычные private методы</li>    
        <li>методы по умолчанию</li>
        <li>статические методы</li>
        <li>вложенные классы</li>
    </ul>
    <ul><b>особенности:</b>
        <li>нельзя создать экземпляр интерфейса</li>
        <li>нет конструктора</li>
        <li>не может содержать поля экземпляров. Могут быть только статическими, и final</li>
        <li>может расширить множество интерфейсов</li>
        <li>Если класс не реализует хотя бы один из методов интерфейса, то этот класс
        должен быть помечен как abstract</li>
    </ul>
    
</details>

<details><summary>Enum</summary>
    <p><b>Enum (перечисление)</b> - специальный Java класс(тип), представляющий собой набор логически связанных констант</p>
    <ul>Перечисления могут определять:
        <li>конструкторы</li>
        <li>поля</li>
        <li>методы</li>
    </ul>
</details>

<details><summary>Зачем нам использовать Enum</summary>
    <ul>
        <li>Перечисления в Java являются типобезопасными и имеют собственное пространство имен. Это означает, что ваше 
            перечисление будет иметь тип, например, «Валюта» в приведенном ниже примере, и вы не можете назначать никакие 
            значения, кроме указанных в константах перечисления.
        </li>
        <li>Это ссылочный тип, такой как класс или интерфейс, и можно определить конструктор, методы и переменные внутри Enum</li>
        <li>простота синтаксиса</li>
        <li>простое использование в switch</li>
        <li>наличие встроенных методов, которые позволяют получить, имя константы, порядковый номер константы, либо массив всех значений перечисления</li>
        <li>высоко оптимизированные реализации классов / интерфейсов API Collection специально для перечислений: в EnumSet и EnumMap</li>
        <li>Безопасность значений. Мы не можем переопределить/изменить значения Enum</li>
    </ul>
</details>

<details><summary>Модификаторы доступа</summary>
    <ul>Классы:
        <li><b>public</b> - видимый(доступный) для всех в пакете и за пределами пакета</li>
        <li><b>по умолчанию</b> - без модификатора, доступен внутри пакета</li>
    </ul>
    <ul>Поле, метод, конструктор:
        <li><b>public</b> - видимый(доступный) для всех в пакете и за пределами пакета</li>
        <li><b>default</b> - доступен внутри пакета (когда не определен ни один из модификаторов)</li>
        <li><b>protected</b> - в пределах всех классов, находящихся в том же пакете, что и наш,
            в пределах всех классов-наследников нашего класса.</li>
        <li><b>private</b> - видимы только в классе, который их определяет</li>
    </ul>
    <a href="http://www.quizful.net/post/features-of-the-application-of-modifiers-in-java">Особенности применения модификаторов в Java</a>
</details>

<details><summary>Object.class</summary>
    <p><b>Object</b> - находится на вершине иерархии всех классов. Другими словами: все
    классы в Java, кроме Object, наследуются (неявно) от класса Object</p>
    <ul><b>Методы класса Object:</b>
        <li><b>hashCode()</b> - возвращает числовое представление объекта. По-умолчанию - целочисленный адрес в памяти</li>
        <li><b>equals()</b> - возвращает результат сравнения двх объектов</li>
        <li><b>toString()</b> - возвращает представление объекта в виде строки. По-умолчанию возвращает имя_класса@hashcode в 16-ричной системе</li>
        <li><b>clone()</b> - получить точную копию объекта. Не рекомендуется использовать. Чаще советуют использовать конструктор копирования.</li>
        <li><b>wait(), notify(), notifyAll()</b> - три метода из набора для многопоточности</li>
        <li><b>getClass()</b> - получить класс объекта во время выполнения. В основном используется для рефлексии</li>
    </ul>
</details>

<details><summary>Контракты equals и hashCode</summary>
    <ul><b>equals:</b>
        <li><b>Рефлексивность</b> - x.equals(x) всегда true, при x != Null</li>
        <li><b>Симметричность</b> - если x.equals(y) == true, то и y.equals(x) == true</li>
        <li><b>Транзитивность</b> - если x.equals(y) == true, а y.equals(z) == true, То и x.equals(z) == true</li>
        <li><b>Согласованность</b> - для заданных значений x и y повторный вызов x.equals(y) будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами</li>
        <li><b>Сравнение null</b> - для любого заданного значения x вызов x.equals(null) должен возвращать false</li>
    </ul>    
    <ul><b>hashCode:</b>
        <li>вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.</li>
        <li>вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).</li>
        <li>вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения</li>
    </ul>
    <a href="https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam">Контракты equals и hashCode или как оно всё там</a>
</details>

<details><summary>java.lang.Class</summary>
    <p>В запущенной программе Java каждому классу соответствует объект типа Class. Этот объект содержит информацию,
    необходимую для описания класса – поля, методы, реализуемые интерфейсы.</p>
    <p>Класс Class не имеет открытого конструктора – объекты этого класса создаются автоматически Java-машиной по мере загрузки классов</p>
    <ul><b>Class</b> есть у:
        <li>классов, интерфейсов, перечислений</li>
        <li>примитивов и обёрток над ними</li>
        <li>массивов</li>   
        <li>void</li>
    </ul>
    <ul><b>Методы:</b>
        <li><b>getDeclaredFields()</b> - возвращает все объявленные переменные в классе</li>
        <li><b>getDeclaredField(String fieldName)</b> - возвращает переменную по её имени. Если переменной с таким именем нет, то метод выбросит checked NoSuchFieldException.</li>
        <li><b>getFields()</b> - возвращает только public переменные</li>
        <li><b>getField(String fieldName)</b> - возвращает только public переменные. Даже если поле с таким именем есть, но оно не публичное, метод getField() бросит NoSuchFieldException</li>
        <li><b>getDeclaredMethods(), getDeclaredMethod(), getMethods(), getMethod()</b> - для методов по аналогии как с полями</li>
        <li><b>getEnclosingMethod()</b> - Если класс является локальным или анонимным, метод getEnclosingMethod() возвращает тот метод в котором этот класс был создан, иначе метод возвращает null</li>
    </ul>
    <a href="https://java-online.ru/java-lang.xhtml#class" >Пакет java.lang</a>
</details>

##Part2
<details><summary>Изменение значения примитива, поля, ссылочного типа при передаче в метод</summary>
    <p>Примитивы передаются в методы по значению, т.е. значение копируется и все операции по изменению этого значения не влияют на значение передуваемого примитива</p>
    <p>Объекты ссылочных типов передаются в метод по ссылке, по этому передоваемый объект и аргумент принимающий этот объект будут ссылаться на один и тот же
    объект в памяти, и производимые изменения с этим объектом в методе будут отражены и в передоваемом объекте</p>
</details>

<details><summary>Зачем нам использовать конструкторы</summary>
    <p>Основная цель конструктора - это правильная инициализация экземпляра класса</p>
    <p>инициализация экземпляра класса: Выделяется ячейка памяти в Heap -> Определяется и возвращается ссылка на эту ячейку -> Вызывается конструктор</p>
    <p><b>Логическое назначение конструктора, то что с помощью конструктора можно задать стандарт создания объекта (экземпляра класса), нарушая который, мы получим
    ошибку во время компиляции и не допустим к выполнению плохо сконструированный класс</b></p>
    <a href="https://www.youtube.com/watch?v=f88zS-etDWs&list=PLsQAG1V_t58AKvV5v4NVXxo68OyLdNX3j&index=21&ab_channel=KovalevskyiAcademy">Модуль 5. Урок 2. Конструкторы в Java.</a>
</details>

<details><summary>Abstract Classes Vs Interface</summary>
    <p>Абстрактные классы используют, когда требуется выделить общие абстрактные свойства будущих объектов, и какую-нибудь стандартную реализацию и поведение</p>
    <p>Интерфейсы используются когда нам надо наделить объект каким-нибудь поведением, учитывая момент, что класс может реализовать множество интерфейсов</p>
    <ul>Абстрактные классы стоит использовать:
        <li>Когда нужно поделиться кодом между тесно связанными классами</li>
        <li>Когда классы, расширяющие абстрактный класс, имеют много общих методов или полей, или требуют других мадификаторов доступа</li>
        <li>Когда надо объявить нестатические и не final поля. Это позволит определять методы, которые могут получить доступ, и изменить состояние объекта, к которому они принадлежат</li>
    </ul>
    <ul>Использование интерфейсов:
        <li>Когда несвязанные классы будут реализовывать интерфейс. Например "Comparable" и "Cloneable" реализуются многими несвязанными классами</li>
        <li>Когда надо определить поведение конкретного типа данных, но вам не важно, кто его реализует</li>
        <li>Для использования множественного наследования типа</li>
    </ul>
    <a href="https://javarush.ru/groups/posts/1985-raznica-mezhdu-abstraktnihmi-klassami-i-interfeysami" >Разница между абстрактными классами и интерфейсами</a>
</details>

<details><summary>Какие типы классов используются для каких целей</summary>
    <ul>
        <li><b>Абстрактный класс</b> - для выделения общих характеристик и стандартной реализации</li>
        <li><b>Интерфейс</b> - наделение объектов поведением</li>
        <li><b>Enum</b> - объединения набора логически связанных констант (цвета, дни недели, месяцы, статус)</li>
        <li><b>Внутренний класс</b> - для обслуживания внешнего класса</li>
        <li><b>Анонимный класс</b> - если нужен локальный класс для одноразового использования</li>
    </ul>
</details>

<details><summary>Может ли класс быть статик</summary>
    <p>Да, если это внутренний класс. Внутренний статический класс, называется <b>вложенным</b></p>
</details>

<details><summary>Назначение final полей</summary>
    <p>Используются как константы, которые инициализируются один раз и их значение нельзя изменить</p>
</details>

<details><summary><b>transient</b></summary>
    <p><b>transient</b> - используется в процессе сериализации и десериализации объектов. Указывается перед полем 
        класса, для обозначения того, что данное поле не должно быть сериализовано.<br>
        <b>Сериализация</b> - это конвертация состояния объекта в последовательность байт.<br>
        <b>Десериализация</b> - это восстонавление объекта из этих байт. 
    </p>
    <ul>Когда стоит использовать:
        <li>Поля, которые вычисляются программно</li>
        <li>Поля с приватной информацией (пароли) </li>
        <li>Поля, классы которых, не реализуют интерфейс Serializable (логгеры, потоки ввода-вывода, объекты, которые хранят соединения с базой данных и прочие служебные классы)</li>
        <li>Поля с информацией не являющейся частью информации о состоянии объекта (для дебага или для выполнения какой то служебной функции, которые не несут информации о состоянии объекта)</li>
    </ul>
    <a href="https://javarush.ru/groups/posts/2898-chto-skrihvaet-modifikator-transient-v-java" >Что скрывает модификатор transient в Java</a>
</details>

<details><summary><b>synchronized</b></summary>
    <p><b>synchronized</b> - это ключевое слово, которое позволяет заблокировать доступ к методу или части кода, если его уже использует другой поток.
       Применяется для метода и для блока кода.
    </p>
</details>

<details><summary><b>volatile</b></summary>
    <p>Ключевое слово <b>volatile</b> указывается для поля, чтобы указать компилятору, что все операции присвоения и чтения из неё должны быть атомарными</p>
    <a href="https://javarush.ru/groups/posts/1998-upravlenie-potokami-metodih-volatile-i-yield">Управление потоками. Ключевое слово volatile и метод yield()</a>
</details>

<details><summary>Можно-ли проинициализировать объект если все его поля приватные?</summary>
    Да
</details>

<details><summary>Два конструктора Cons(String) Cons(Integer) каким образом конструктор 1 может вызвать конструктор 2</summary>
    Const(String){
        this(666)
    }
</details>

<details><summary>Рефлекcия</summary>
    <p><b>Рефлексия</b> - это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет 
    исследовать информацию о полях, методах и конструкторах классов</p>
    <ul>С помощью рефлексии можно:
        <li>Узнать/определить класс объекта</li>
        <li>Получить информацию о модификаторах класса, полях, методах, константах, конструкторах и суперклассах</li>
        <li>Выяснить, какие методы принадлежат реализуемому интерфейсу/интерфейсам</li>
        <li>Создать экземпляр класса, причем имя класса неизвестно до момента выполнения программы</li>
        <li>Получить и установить значение поля объекта по имени</li>
        <li>Вызвать метод объекта по имени</li>
    </ul>
    <a href="https://javarush.ru/groups/posts/513-reflection-api-refleksija-temnaja-storona-java" >Reflection API. Рефлексия. Темная сторона Java</a>
</details>

<details><summary>Множественное наследование</summary>
    <p>Java не поддерживает множественное наследование. Если класс будет наследоваться от нескольких классов, у которых
    есть одинаковый метод с различной реализацией, класс потомок не будет знать какую из реализаций выбрать</p>
    <p><b>Ромбовидное наследование:</b></p>
    <img src="https://cdn.javarush.ru/images/article/a1a82157-5a52-48ab-96f9-8fad0891f520/512.webp">
</details>

<details><summary>Модификатор доступа по умолчанию в интерфейсах</summary>
    <p>Модификатором доступа <b>default</b> в интерфейсах помечаются методы, имеющие реализацию. Так же такой метод будет доступен в классе, который
    его реализует этот интерфейс. Так же класс не обязан переопределять этот метод, тем самым не ломается программа, которая до этого использовала
    этот метод, после добавления в него метода по умолчанию</p>
</details>

<details><summary>Почему статика не может использовать нестатику</summary>
    <p>Нестатические методы\поля - методы\поля экземпляра класса<br>
        Статические методы\поля - методы\поля самого класса<br>
        Статический метод, не имея в распоряжении экземпляра класса, не может вызывать нестатический метод\поле непонятно кого<br>
        Статические поля инициализируются во время загрузки класса, а нестатические во время создания экземпляра класса</p>
</details>

<details><summary>Полиморфизм</summary>
    <h4>Статический полиморфизм</h4>
    <p>Достигается за счет перегрузки методов. Перегрузка метода означает, что в классе есть несколько методов, имеющих одинаковое имя, 
    но разные типы/порядок/количество параметров. Во время компиляции Java знает, какой метод вызывать, проверяя сигнатуры метода.
    Это называется <b>полиморфизмом времени компиляции</b> или <b>статическим связыванием</b> </p>
    <h4>Динамический полиморфизм</h4>
    <p>Это механизм, с помощью которого можно определить несколько методов с одинаковыми именами и сигнатурами в суперклассе и подклассе. 
    Вызов переопределенного метода разрешается во время выполнения.</p>
</details>