<h2>Streams IO:</h2>
<details><summary>Что такое IO и какие типы io стримов ты знаешь? (byte and character)</summary>
    <p><b>Потоки ввода-вывода</b> - это абстракция для поставки или потребления информации. Поток ввода-вывода связан с
        физическим устройством ввода-вывода (файл на жестком диске, интернет соединение и тд)
    </p>
    <ul>Виды потоков
        <li><b>Байтовый</b> - средства для управления вводом и выводом отдельных байтов, например, при чтении и записи двоичных данных.
            InputStream, OutputStream - абстрактные классы, определяющие абстрактные методы read() и write() для чтения и записи байт соответственно
        </li>
        <li><b>Символьный</b> - средства управления вводом и выводом отдельных символов. Reader, Writer - абстрактные классы, управляющие потокми ввода/вывода
            символов в Кодировке Юникод.
        </li>
    </ul>
</details>
<details><summary>Приведи примеры I / O стримов? (OutputStream, Writer)</summary>
    <ul>Байтовые:
        <li><b>FileInputStream</b> - читает данные из файла</li>
        <li><b>BufferedInputStream</b> - буферизованный поток ввода</li>
        <li><b>ObjectInputStream</b> - поток ввода объектов</li>
        <li><b>FileOutputStream</b> - поток вывода, записывающий данные в файл</li>
        <li><b>BufferedOutputStream</b> - буферизованный поток вывода</li>
        <li><b>PrintStream</b> - поток вывода, содержащий методы print{) и println()</li>
    </ul>
    <ul>Строковые:
        <li><b>FileReader</b> - Поток ввода, читающий символы из файла</li>
        <li><b>BufferedReader</b> - буферизованный поток ввода символов</li>
        <li><b>FilterReader</b> - Фильтрованный поток чтения</li>
        <li><b>FileWriter</b> - Поток вывода, записывающий символы в файл</li>
        <li><b>BufferedWriter</b> - Буферизированный поток вывода символов</li>
        <li><b>StringWriter</b> - Поток вывода, записывающий символы в строку</li>
    </ul>
</details>
<details><summary>Что делает поток, если его не закрыть?</summary>
    <p>Не закрытый поток использует ресурсы, которые были выделены для него</p>
</details>
<details><summary>Как правильно закрывать поток?</summary>
    <p>Для закрытия потоков используется метод close()</p>
    <p>Потоки в Java могут выбрасывать исключения, по этому работа с ними происходит в блоках try-catch</p>
    <p>Если во время работы с потоком будет выброшено исключение, мы должны в блоке finally вызывать метод close() у экземпляра потока</p>
    <p>Либо, если поток реализует интерфейс AutoCloseable, то мы можем использовать try-catch с ресурсами</p>
</details>
<details><summary>Как работают следующие элементы пакета io: InputStream, OutputStream, Reader, Writer?</summary>
    <p><b>InputStream</b> - абстрактный класс описывающий абстрактный метод read(), является суперклассом для всех классов,
        которые представляют поток чтения байт
        <ul>Методы:
            <li><b>abstract int read() throws IOException</b> - возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1</li>
            <li><b>int read(byte b[]) throws IOException</b> - считывает байты из потока в массив buffer. После чтения возвращает число считанных байтов. Если ни одного байта не было считано, то возвращается число -1</li>
            <li><b>int read(byte[] buffer, int offset, int length)</b> - считывает некоторое количество байтов, равное length, из потока в массив buffer. При этом считанные байты помещаются в массиве, начиная со смещения offset, то есть с элемента buffer[offset]. Метод возвращает число успешно прочитанных байтов</li>
            <li><b>void close() throws IOException</b> - закрывает поток</li>
            <li><b>int available() throws IOException</b> - возвращает количество байтов, доступных для чтения в потоке</li>
            <li><b>long skip(long n) throws IOException</b> - пропускает в потоке при чтении некоторое количество байт, которое равно number</li>
        </ul>
    </p>
    <p><b>OutputStream</b> - абстрактный класс описывающий абстрактный метод write(), является суперклассом для всех классов,
        которые представляют поток вывода байт.
        <ul>Методы:
            <li><b>abstract void write(int b) throws IOException</b> - записывает в выходной поток один байт, который представлен целочисленным параметром b</li>
            <li><b>void write(byte buffer[]) throws IOException</b> - записывает в выходной поток массив байтов buffer</li>
            <li><b>void write(byte[] buffer, int offset, int length)</b> - записывает в выходной поток некоторое число байтов, равное length, из массива buffer, начиная со смещения offset, то есть с элемента buffer[offset]</li>
            <li><b>void close() throws IOException</b> - закрывает поток</li>
            <li><b>void flush() throws IOException</b> - очищает буфер вывода, записывая все его содержимое</li>
        </ul>
    </p>
    <p><b>Reader</b> - абстрактный класс для чтения потоков символов. Его подклассы должны реализовать методы read() и close()</p>
    <p><b>Writer</b> - абстрактный класс для записи символов в поток. Его подклассы должны реализовать методы write(char[], int, int), flush() и close()</p>
</details>
<details><summary>Для чего реализованы различные потоки ввода вывода</summary>
    <p>Если мы работаем с потоками представляющие текстовую информацию, удобней использовать символьные потоки. И если работает с байтами либо с бинарной информацией, то
        надо использовать байтовые потоки
    </p>
    <p>Существуют различные реализации, так как источник или приемник информации может быть разный (файл на диске, порт сетевой карты, usb интерфейс ПК и тд)
        каждый этот источник/приемник работает по разному, для этого и нужны разные реализации
    </p>
</details>
<details><summary>try-catch область видимости переменных?</summary>
    <p>Блоки try-catch-finally создают свои отдельные области видимости. Всё что объявленно в try не будет доступно в catch или finally</p>
    <p>всё что объявленно в блоке ресурсов, будет доступно в блоке try</p>
</details>
<details><summary>Что такое RandomAccessFile?</summary>
    <a href="https://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html">RandomAccessFile - docs</a><br>
    <a href="https://www.baeldung.com/java-write-to-file#write-with-randomaccessfile">RandomAccessFile - Baeldung</a>
    <p>Позволяет перемещаться по файлу, читать из него или писать в него</p>
</details>
<details><summary>Какие типы (записи/чтения) файлов бывают?</summary>
    <p>У файлов есть может быть атрибут "только для чтения". Такой файл можно открыть и просмотреть, как и любой другой файл, но запись в файл будет невозможна</p>
</details>
<details><summary>Сепораторы путей Java</summary>
    <p>Для разных ОС сепораторы могут быть разные, но / - будет работать везде и \\ : <br>
        "если в качестве такого разделителя используется знак косой
        черты(/) в версии Java для Windows, путь к файлу будет все равно сформирован правильно. Не
        следует, однако, забывать, что для употребления знака обратной косой черты(\) в символьных
        строках под Windows его следует экранировать в виде управляющей последовательности(\\)."
    </p>
</details>
<details><summary>Что ты знаешь о классах аддонах в рамках IO?</summary>
    <p>В IO существуют классы буферизированных потоков такие как InputBufferedStream, OutputBufferedStream, BufferedReader и BufferedReader. Они обеспечивают более быструю
        работы с потоками, т.к. для буфера выделяется память, а чтение/запись из памяти гораздо быстрей, чем, например, из файла. Так же производительность достигается
        за счет возможности одновременного ввода-вывода в поток
    </p>
</details>
<h2>Сериализация:</h2>
<details><summary>Что такое сериализация? Для чего она нам? Приведи примеры сериализации?</summary>
    <p>Это процесс записи состояния объектов в поток вывода байтов с возможностью дальнейшего восстановления</p>
    <p>Сериализация нужна, для обмена данными, между машинами. Например, нам нужно передать объект по сети, мы его сериализуем в поток байт, передаем по сети,
        на другой машине принимают этот поток и десериализуют обратно в поток. Так же происходит поддержка кроссплатформенности
    </p>
    <p>Для сериализации объектов, класс этого объекта должен реализовывать интерфейс маркер <b>Serializable</b></p>
    <p>Значения полей, которые не нужно сериализовать, помечаются модификатором <b>transirnt</b></p>
</details>
<details><summary>Правила сериализации?</summary>
    <ul>transient используется для:
        <li>полей, которые несут приватную информацию (пароли)</li>
        <li>полей, которые вычисляются проограммно, в зависимости от других полей</li>
        <li>полей, которые не влияют на состояние объекта, служебная информация или информация для дебага</li>
        <li>полей, классы которых не реализуют интерфейс Serializable (логгеры, потоки ввода-вывода, объекты, которые хранят соединения с базой данных и прочие служебные классы)</li>
    </ul>
</details>
<details><summary>Что в рамках десериализации/сериализации будет являться успехом?</summary>
    <p>Когда мы получим после десериализации состояние объекта, которое было до сериализации и удовлетворяющее бизнесс требованиям которые заложены при разработке</p>
</details>
<details><summary>Поведение базового и потомка при сериализации?</summary>
    <p>1. Если родительский класс будет реализовывать Serializable, то и потомок этого класса тоже будет сеарелизуемым</p>
    <p>2. Если класс родитель не будет серивлизуемым, а потомок буде, то для успешной десериализации, надо чтоб у класса родителя был конструктор без параметров</p>
</details>
<details><summary>Интерфейсы реализуемые при сериализации?</summary>
    <p><b>Serializable</b> - интерфейс маркер, без методов</p>
    <p><b>Externalizable</b> - интерфейс содержит два метода, которые необходимо реализовать – writeExternal(ObjectOutput) и readExternal(ObjectInput). В этих методах как раз и находится логика сериализации/десериализации</p>
</details>
<details><summary>Изменение поведения сериализации?</summary>
    <p>Ключевое слово <b>transient</b> служит для определения полей, которые не надо сериализовать. Таким образом служит для изменения поведения сериализации.
        При десериализации эти поля будут заполнены начальными значениями (null). Но в классе, объекты которого, мы собираемся сериализовать, можно описать 2 метода, такие как:
        writeObject, readObject в которых можно указать действия при сериализации или десериализации, определить инициализацию значений по умолчанию
    </p>
</details>
<h2>NIO</h2>
<details><summary>Причины появления nio</summary>
    <p>Для улучшения производительности, и работа в многопоточных средах</p>
    <a href="https://www.tune-it.ru/web/ivanuskov/blog/-/blogs/java-nio">Java NIO</a>
    <ul>Особенности nio:
        <li><b>Неблокирующий</b> - не ожидает появления данных в канале (см. далее), а получает уже имеющиеся в нём данные, а если их нет - не получает ничего, после этого программа может перейти к исполнению следующих инструкций</li>
        <li><b>Асинхронный</b> - данные в канал поступают независимо от программы - достаточно связать канал с источником данных, и при их появлении они будут "кэшироваться" в нём. Операция чтения из канала просто получит уже имеющиеся в нём данные</li>
        <li><b>Буфер-ориентированный</b> - работает с буферами, которые можно воспринимать как высокоуровневые обёртки над массивом байт. В отличие от буферизации в том же BufferedInputStream'е (и прочих Buffered*), программисту даётся полный контроль над буфером: существует большое число методов по модификации его содержимого, навигации</li>
    </ul>
</details>
<details><summary>Принцип работы nio</summary>
    <p>Система ввода-вывода NIO построена на двух основополагающих элементах: буферах и каналах. В буфере хранятся данные, 
        а канал предоставляет открытое соединение с устройством ввода-вывода, например файлом или сокетом. В общем, для применения системы ввода-вывода NIO
        требуется получить канал для устройства ввода-вывода и буфер для хранения данных. После этого можно оперировать буфером, вводя или выводя данные по мере надобности.
    </p>
    <p><b>Буфер</b> - буферы являются подклассами класса Buffer.</p>
    <p><b>Канал</b> - представляет открытое соединение с источником или адресатом ввода-вывода. Классы каналов реализуют интерфейс Channel, расширяющий интерфейс CloseaЬle, а также
интерфейс AutoCloseaЫe.</p>
</details>
<details><summary>Главные отличия nio от io</summary>
    <a href="https://habr.com/ru/post/235585/">Основные отличия Java IO и Java NIO</a>
    <ul>
        <li>IO - потокаариентированный, NIO - буфероариентированный</li>
        <li>IO - блокирующий (синхронный) (останавливает поток выполнения, пока работает поток ввода/вывода), NIO (асинхронный) - не блокирует</li>
    </ul>
</details>
<details><summary>Селекторы в nio</summary>
    <img src="https://habrastorage.org/r/w1560/files/a94/67c/af7/a9467caf787342a5989544393b1af488.png"><br>
    <p>Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода</p>
    <p>Понимание: есть три железнодорожных пути (каналы), на каждый из них в любой момент времени может прибыть поезд (данные из буфера), на каждом 
        пути постоянно ожидает сотрудник вокзала (поток выполнения), задача которого – обслуживание прибывшего поезда. В результате трое сотрудников постоянно 
        находятся на вокзале даже если там вообще нет поездов. Вариант с селектором: ситуация та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику 
        вокзала (поток выполнения) о прибытии поезда. Таким образом на вокзале достаточно присутствия одного сотрудника
    </p>
</details>
<details><summary>SelectionKey? Получение событий из канала в nio</summary>
    <a href="https://www.baeldung.com/java-nio-selector">Introduction to the Java NIO Selector</a><br>
    <p><b>Селектор</b> - предоставляет механизм для мониторинга одного или нескольких каналов NIO и распознавания, когда один или несколько становятся доступными для передачи данных</p>
    <p>Таким образом, один поток может использоваться для управления несколькими каналами и, следовательно, несколькими сетевыми соединениями</p>
    <p><b>SelectionKey</b> - содержит данные о регистрации канала</p>
    <ul>Selection keys:
        <li><b>Connect</b> - когда клиент пытается подключиться к серверу. SelectionKey.OP_CONNECT</li>
        <li><b>Accept</b> - когда сервер принимает соединение от клиента. SelectionKey.OP_ACCEPT</li>
        <li><b>Read</b> - когда сервер готов читать из канала. SelectionKey.OP_READ</li>
        <li><b>Write</b> - когда сервер готов писать в канал. SelectionKey.OP_WRITE</li>
    </ul>
</details>