<h2>Streams IO:</h2>
<details><summary>Что такое IO? Для чего нам надо?</summary>
    <p><b>Поток ввода-вывода</b> - это абстракция для передачи (отправки/получения (ввода-вывода)) данных, которая связан с
        физическим устройством ввода-вывода (файл на жестком диске, интернет соединение и тд)
    </p>
    <p>Используется для обмена данными между программами, компьютерами, устройствами, т.к. большинство программ не существуют сами по себе, а предназначены для обработки данных,
        которые они берут из вне, либо куда то отправляют, предварительно обработав
    </p>
</details>
<details><summary>Типы стримов?</summary>
    <ul>
        <li><b>Байтовый</b> - средства для управления передачи отдельных байтов, например, при чтении и записи двоичных данных.
            InputStream, OutputStream - абстрактные классы, определяющие абстрактные методы read() и write() для чтения и записи байт соответственно
        </li>
        <li><b>Символьный</b> - средства управления передачи отдельных символов. Reader, Writer - абстрактные классы, управляющие потокми ввода/вывода
            символов в Кодировке Юникод.
        </li>
    </ul>
</details>
<details><summary>Преимущества IO</summary>
    <ul>
        <li><b>Потокобезопастность</b></li>
        <li><b>Относительная простота использования</b></li>
        <li><b>Множество готовых реализаций в Java</b></li>
    </ul>
</details>
<details><summary>Недостатки IO</summary>
    <ul>
        <li><b>Потокобезопастность</b></li>
        <li><b>Нет возможность гибкой обработки передаваемых данных</b></li>
        <li><b>Возможность утечки памяти при не закрытом стриме</b></li>
    </ul>
</details>
<details><summary>Приведи примеры I / O стримов? (OutputStream, Writer)</summary>
    <ul>Байтовые:
        <li><b>FileInputStream</b> - читает данные из файла</li>
        <li><b>BufferedInputStream</b> - буферизованный поток ввода</li>
        <li><b>ObjectInputStream</b> - поток ввода объектов</li>
        <li><b>FileOutputStream</b> - поток вывода, записывающий данные в файл</li>
        <li><b>BufferedOutputStream</b> - буферизованный поток вывода</li>
        <li><b>PrintStream</b> - поток вывода, содержащий методы print{) и println()</li>
    </ul>
    <ul>Строковые:
        <li><b>FileReader</b> - Поток ввода, читающий символы из файла</li>
        <li><b>BufferedReader</b> - буферизованный поток ввода символов</li>
        <li><b>FilterReader</b> - Фильтрованный поток чтения</li>
        <li><b>FileWriter</b> - Поток вывода, записывающий символы в файл</li>
        <li><b>BufferedWriter</b> - Буферизированный поток вывода символов</li>
        <li><b>StringWriter</b> - Поток вывода, записывающий символы в строку</li>
    </ul>
</details>
<details><summary>Что делает поток, если его не закрыть?</summary>
    <p>Не закрытый поток использует ресурсы, которые были выделены для него</p>
</details>
<details><summary>Как правильно закрывать поток?</summary>
    <p>Для закрытия потоков используется метод close()</p>
    <p>Потоки в Java могут выбрасывать исключения, по этому работа с ними происходит в блоках try-catch</p>
    <p>Если во время работы с потоком будет выброшено исключение, мы должны в блоке finally вызывать метод close() у экземпляра потока</p>
    <p>Либо, если поток реализует интерфейс AutoCloseable, то мы можем использовать try-catch с ресурсами</p>
</details>
<details><summary>Как работают следующие элементы пакета io: InputStream, OutputStream, Reader, Writer?</summary>
    <p><b>InputStream</b> - абстрактный класс описывающий абстрактный метод read(), является суперклассом для всех классов,
        которые представляют поток чтения байт
        <ul>Методы:
            <li><b>abstract int read() throws IOException</b> - возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1</li>
            <li><b>int read(byte b[]) throws IOException</b> - считывает байты из потока в массив buffer. После чтения возвращает число считанных байтов. Если ни одного байта не было считано, то возвращается число -1</li>
            <li><b>int read(byte[] buffer, int offset, int length)</b> - считывает некоторое количество байтов, равное length, из потока в массив buffer. При этом считанные байты помещаются в массиве, начиная со смещения offset, то есть с элемента buffer[offset]. Метод возвращает число успешно прочитанных байтов</li>
            <li><b>void close() throws IOException</b> - закрывает поток</li>
            <li><b>int available() throws IOException</b> - возвращает количество байтов, доступных для чтения в потоке</li>
            <li><b>long skip(long n) throws IOException</b> - пропускает в потоке при чтении некоторое количество байт, которое равно number</li>
        </ul>
    </p>
    <p><b>OutputStream</b> - абстрактный класс описывающий абстрактный метод write(), является суперклассом для всех классов,
        которые представляют поток вывода байт.
        <ul>Методы:
            <li><b>abstract void write(int b) throws IOException</b> - записывает в выходной поток один байт, который представлен целочисленным параметром b</li>
            <li><b>void write(byte buffer[]) throws IOException</b> - записывает в выходной поток массив байтов buffer</li>
            <li><b>void write(byte[] buffer, int offset, int length)</b> - записывает в выходной поток некоторое число байтов, равное length, из массива buffer, начиная со смещения offset, то есть с элемента buffer[offset]</li>
            <li><b>void close() throws IOException</b> - закрывает поток</li>
            <li><b>void flush() throws IOException</b> - очищает буфер вывода, записывая все его содержимое</li>
        </ul>
    </p>
    <p><b>Reader</b> - абстрактный класс для чтения потоков символов. Его подклассы должны реализовать методы read() и close()</p>
    <p><b>Writer</b> - абстрактный класс для записи символов в поток. Его подклассы должны реализовать методы write(char[], int, int), flush() и close()</p>
</details>
<details><summary>Для чего реализованы различные потоки ввода вывода</summary>
    <p>Если мы работаем с потоками представляющие текстовую информацию, удобней использовать символьные потоки. И если работает с байтами либо с бинарной информацией, то
        надо использовать байтовые потоки
    </p>
    <p>Существуют различные реализации, так как источник или приемник информации может быть разный (файл на диске, порт сетевой карты, usb интерфейс ПК и тд)
        каждый этот источник/приемник работает по разному, для этого и нужны разные реализации
    </p>
</details>
<details><summary>try-catch область видимости переменных?</summary>
    <p>Блоки try-catch-finally создают свои отдельные области видимости. Всё что объявленно в try не будет доступно в catch или finally</p>
    <p>всё что объявленно в блоке ресурсов, будет доступно в блоке try</p>
</details>
<details><summary>Что такое RandomAccessFile?</summary>
    <a href="https://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html">RandomAccessFile - docs</a><br>
    <a href="https://www.baeldung.com/java-write-to-file#write-with-randomaccessfile">RandomAccessFile - Baeldung</a>
    <p>Позволяет перемещаться по файлу, читать из него или писать в него</p>
</details>
<details><summary>Какие типы (записи/чтения) файлов бывают?</summary>
    <p>У файлов есть может быть атрибут "только для чтения". Такой файл можно открыть и просмотреть, как и любой другой файл, но запись в файл будет невозможна</p>
</details>
<details><summary>Сепораторы путей Java</summary>
    <p>Для разных ОС сепораторы могут быть разные, но / - будет работать везде и \\ : <br>
        "если в качестве такого разделителя используется знак косой
        черты(/) в версии Java для Windows, путь к файлу будет все равно сформирован правильно. Не
        следует, однако, забывать, что для употребления знака обратной косой черты(\) в символьных
        строках под Windows его следует экранировать в виде управляющей последовательности(\\)."
    </p>
</details>
<details><summary>Что ты знаешь о классах аддонах в рамках IO?</summary>
    <p>В IO существуют классы буферизированных потоков такие как InputBufferedStream, OutputBufferedStream, BufferedReader и BufferedReader. Они обеспечивают более быструю
        работы с потоками, т.к. для буфера выделяется память, а чтение/запись из памяти гораздо быстрей, чем, например, из файла. Так же производительность достигается
        за счет возможности одновременного ввода-вывода в поток
    </p>
</details>
<h2>Сериализация:</h2>
<details><summary>Что такое сериализация? Для чего она нам? Приведи примеры сериализации?</summary>
    <p>Это процесс записи состояния объектов в поток вывода байтов с возможностью дальнейшего восстановления</p>
    <p>Сериализация нужна, для обмена данными, между машинами. Например, нам нужно передать объект по сети, мы его сериализуем в поток байт, передаем по сети,
        на другой машине принимают этот поток и десериализуют обратно в поток. Так же происходит поддержка кроссплатформенности
    </p>
    <p>Для сериализации объектов, класс этого объекта должен реализовывать интерфейс маркер <b>Serializable</b></p>
    <p>Значения полей, которые не нужно сериализовать, помечаются модификатором <b>transirnt</b></p>
</details>
<details><summary>Правила сериализации?</summary>
    <ul>transient используется для:
        <li>полей, которые несут приватную информацию (пароли)</li>
        <li>полей, которые вычисляются проограммно, в зависимости от других полей</li>
        <li>полей, которые не влияют на состояние объекта, служебная информация или информация для дебага</li>
        <li>полей, классы которых не реализуют интерфейс Serializable (логгеры, потоки ввода-вывода, объекты, которые хранят соединения с базой данных и прочие служебные классы)</li>
    </ul>
</details>
<details><summary>Что в рамках десериализации/сериализации будет являться успехом?</summary>
    <p>Когда мы получим после десериализации состояние объекта, которое было до сериализации и удовлетворяющее бизнесс требованиям, которые заложены при разработке</p>
</details>
<details><summary>Поведение базового и потомка при сериализации?</summary>
    <p>1. Если родительский класс будет реализовывать Serializable, то и потомок этого класса тоже будет сеарелизуемым</p>
    <p>2. Если класс родитель не будет серивлизуемым, а потомок буде, то для успешной десериализации, надо чтоб у класса родителя был конструктор без параметров</p>
</details>
<details><summary>Интерфейсы реализуемые при сериализации?</summary>
    <p><b>Serializable</b> - интерфейс маркер, без методов</p>
    <p><b>Externalizable</b> - интерфейс содержит два метода, которые необходимо реализовать – writeExternal(ObjectOutput) и readExternal(ObjectInput). В этих методах как раз и находится логика сериализации/десериализации</p>
</details>
<details><summary>Изменение поведения сериализации?</summary>
    <p>Ключевое слово <b>transient</b> служит для определения полей, которые не надо сериализовать. Таким образом служит для изменения поведения сериализации.
        При десериализации эти поля будут заполнены начальными значениями (null). Но в классе, объекты которого, мы собираемся сериализовать, можно описать 2 метода, такие как:
        writeObject, readObject в которых можно указать действия при сериализации или десериализации, определить инициализацию значений по умолчанию
    </p>
</details>
<details><summary>serialVersionUID</summary>
    <a href="https://www.baeldung.com/java-serial-version-uid">What is the serialVersionUID?</a>
    <a href="https://javarush.ru/groups/posts/1034-zachem-ispoljhzovatjh-serialversionuid-vnutri-serializable-klassa-v-java">Зачем использовать SerialVersionUID внутри Serializable класса в Java</a><br>
    <p>serialVersionUID используется для сравнения, что сериализуемый класс и сериализованный объект совместимы. Тк класс может быть изменен</p>
    <p>Если мы сериализуем экземпляр класса, и потом изменим класс, при десериализации получим исключение </p>
</details>
<h2>NIO</h2>
<details><summary>Что такое, для чего надо и причины появления NIO</summary>
    <a href="https://jenkov.com/tutorials/java-nio/index.html" >Java NIO Tutorial</a><br>
    <p><b>NIO</b> - new IO - альтернативная реализация стримов Java. Иногда NIO называют неблокирующими стримами, но некоторые части из NIO блокируются</p>
    <p>Причины появления и использования: для более гибкого управления и обработки данных в стримах</p>
    <ul>Java NIO основана на 3х основных компонентах:
        <li><b>Каналы</b></li>
        <li><b>Буферы</b></li>
        <li><b>Селекторы</b></li>
    </ul>
</details>
<details><summary>Главные отличия nio от io</summary>
    <a href="https://habr.com/ru/post/235585/">Основные отличия Java IO и Java NIO</a>
    <h4>01. IO - потокоориентированный, NIO - буфероориентированный:</h4>
    <p><b>Потокоориентированность</b> - это значит что, обработка одного или нескольких байт данных, в единицу времени происходит поочередно.
        Данная информация ни где не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. Если надо произвести подобные манипуляции,
        придется сначала кэшировать данные в буфере
    </p>
    <p><b>Буфероориентированность</b> - приходящие данные или отправляемые, всегда пишутся в буфер. По буферу можно передвигаться и делать гибкие манипуляции</p>
    <h4>02. IO - блокирующий, NIO - частично неблокирующий:</h4>
    <p>Во время чтения/записи данных в IO поток выполнения, в котором выполняются эти операции, блокируется до момента завершения этих операций</p>
    <p>NIO предлагает гибкую реализацию, при которой можно запрашивать данные, обрабатывать только те данные, которые доступно в данный момент,
        либо вообще не обрабатывать, и тем самым не блокируя (не останавливая) поток выполнения
    </p>
    <h4>03. Мультипоточность:</h4>
    <p>В IO в одном потоке выполнения, в одно время может работать только один стрим (т.к. IO Блокирующий)</p>
    <p>В NIO представлен механизм, при котором есть возможность работы с несколькими стримами в одном потоке выполнения, реализуемые с помощью каналов и селекторов</p>
</details>
<details><summary>Для чего нужен NIO</summary>
    <p></p>
</details>
<details><summary>Преимущества NIO</summary>
    <ol>Все приемущества вытекают из свойств <b>буфероориентированности</b> и <b>не блокируемости</b>
        <li><b>Гибкость</b> - можно более гибко управлять/обрабатывать данные в стриме, за счет работы с буфером, каналами и селектороми</li>
        <li><b>Производительность</b> - из-за гибкости, тонких настроек, и "неблокирования" можно создавать более производительные приложения,
            т.к. мы можем работать с несколькими стримами в одном потоке выполнения и не тратить перформанс на переключение между потоками выполнения, что является
            более ресурснозатратно<br>
            Так же под буфер выделяется один постоянный "кусок" памяти, который оптимизирован с работой кеша процессора, и по которому "бегают"
            маркеры (position, limit), тем самым достигается производительность, из-за того что мы не переопределяем области памяти, а работа
            кэш памяти процессора является еще более производительной чем ОЗУ
        </li>
        <li><b>Память</b> - вытекает из не блокируемости, так как на обработку множества стримов, можно использовать меньше потоков выполнения,
            т.к. каждый поток выполнения забирает на себя много памяти, даже если он не задействован
        </li>
    </ol>
</details>
<details><summary>Недостатки NIO</summary>
    <ol>
        <li><b>Сложность</b> - преимущество гибкости, несет в себе сложность, т.к. кроме бизнес логики обработки данных надо создавать, настраивать,
            связывать между собой, такие абстракции как: каналы, буферы селекторы
        </li>
        <li><b>Не потокобезопастность</b> - т.к. обработка данных может происходить в неблокирующем режиме, поток выполнения продолжать работать, а без обработанных данных,
            его выполнение может быть бессмысленно или вообще нарушить работу программы 
        </li>
    </ol>
</details>
<details><summary>Каналы</summary>
    <a href="https://github.com/andrew-savich/course/blob/master/Streams/src/main/java/com/epam/streams/theory/nio/BasicChannelExample.java">Пример чтения данных из FileChannel в буфер</a><br>
    <p>Все операции ввода-вывода начинаются с каналов. Из канала информация может быть прочитана в буфер или записана из буфера в канал</p>
    <p>В Java канал представлен интерфейсом <b>Channel</b> и имеет ряд основных реализаций:</p>
    <ul>
        <li><b>FileChannel</b> - читает и записывает данные из файла или в файл</li>
        <li><b>DatagramChannel</b> - читает и записывает данные по сети через UDP (протокол пользовательских датаграмм)</li>
        <li><b>SocketChannel</b> - читает и записывает данные по сети через TCP</li>
        <li><b>ServerSocketChannel</b> - позволяет прослушивать входящие соединения TCP. Для каждого входящего соединения создается SocketChannel</li>
    </ul>
</details>
<details><summary>Буферы</summary>
    <p>Буферы в Java NIO используются при взаимодействии с каналами. Данные читаются из канала в буфер, или записываются из буфера в канал</p>
    <p>По сути буфер это блок памяти, в которую записываются, и из которой читаются данные</p>
    <p>Эта часть памяти, которая заключена в объекте NIO буфера, который представляет набор методов, облегчающих работу с блоком памяти</p>
    <ul>Шаги при использовании буфера для чтения и записи данных:
        <li>Запись данных в буфер</li>
        <li>Вызов у буфера метода flip()</li>
        <li>Чтение данных из буфера</li>
        <li>Вызов у буфера метода clear() или compact()</li>
    </ul>
    <p>Когда мы записываем данные в буфер, он отслеживает сколько данных мы записали</p>
    <p>Как только нам нужно прочитать данные, нам нужно переключить буфер с режима записи в чтение используя метод <b>flip()</b></p>
    <p>В режиме чтения, буфер позволяет прочитать все данные, которые были записаны в буфер</p>
    <p>После того когда мы прочитали все данные, нам надо очистить буфер, чтоб подготовить его снова к записи. Можно это сделать двумя путями:<br>
        1) вызов метода clear() - очищает весь буфер<br>
        2) вызов метода compact() - очищает только те данные, которые были прочитаны, а непрочитанные данные перемещаются в начало буфера, и новые данные будут записыватьзя после них
    </p>
</details>
<details><summary>Буфер Capacity, Position, Limit</summary>
    <ul>Свойства буфера:
        <li><b>Capacity</b> - </li>
        <li><b>Position</b> - запись и чтение в буфер производится относительно указателя position</li>
        <li><b>Limit</b> - "индекс" дальше которого не может "зайти" позиция при чтении или записи</li>
    </ul>
    <p>Значения position и limit зависят от того в каком режиме находится буфер (чтение или запись). Значение capacity всегда одно и тоже не зависимо от режима</p>
    <img src="https://jenkov.com/images/java-nio/buffers-modes.png" width="40%"><br>
    <h4>Capacity</h4>
    <p>Буфер имеет определенный фиксированный размер (capacity). Когда буфер заполняется его надо очистить</p>
    <h4>Position</h4>
    <p>Данные записываются в определенную позицию (position), которая изначально ровна 0. Когда byte, long будут записаны, posiyion сдвинется на одну ячейкую
        Максимальное значение которое может приянть position - это capacity - 1
    </p>
    <p>Чтение данных из буфера так же начинается с position. Когда мы переключаем режим из записи в чтение методом flip(), position 
        сбрасывается на 0. Так же при чтении данных position сдвигается по мере чтения
    </p>
    <h4>Limit</h4>
    <p>В режиме записи предел буфера — это предел того, сколько данных можно записать в буфер. В режиме записи limit равен capacity буфера</p>
    <p>При переключении буфера в режим чтения limit означает ограничение того, сколько данных можно прочитать. Следовательно, при Limit устанавливается
        значение position, которое было установлено при записи, и потом position сбрасывается на 0. Другими словами: <b>мы можем прочитать столько байт, сколько было записано</b>
    </p>
    <ul>Ркализации буферов
        <li>ByteBuffer</li>
        <li>MappedByteBuffer</li>
        <li>CharBuffer</li>
        <li>DoubleBuffer</li>
        <li>FloatBuffer</li>
        <li>IntBuffer</li>
        <li>LongBuffer</li>
        <li>ShortBuffer</li>
    </ul>
    <p>Типы Buffer представляют разные типы данных. Другими словами, они позволяют работать с байтами в буфере как с char, short, int, long, float или double</p>
    <h4>Выделение буфера (allocate):</h4>
    <p>Чтоб получить объект буфера, его надо выделить. Для эьтого в каждом классе Buffer есть метод allocate(). Примеры:<br>
        ByteBuffer buf = ByteBuffer.allocate(48);//выделение буфера, хранящий данные типа byte ёмкостью 48 байт<br>
        CharBuffer buf = CharBuffer.allocate(1024);//символьный буфер ёмкостью 1024
    </p>
    <h4>Запись данных в буфера</h4>
    <ol>два пути:
        <li>запись данных из Channel<br>
            int bytesRead = inChannel.read(buf);
        </li>
        <li>запись данных самостоятельно с помощью метода put()<br>
            buf.put(127);    
        </li>
    </ol>
    <h4>Чтение данных из буфера</h4>
    <ol>два пути:
        <li>чтение данных из буфера в канал<br>
            int bytesWritten = inChannel.write(buf);
        </li>
        <li>чтение данных самостоятельно с помощью метода get()<br>
            byte aByte = buf.get();    
        </li>
    </ol>
    <h4>метод rewind()</h4>
    <p>Buffer.rewind() сбрасывает position на 0, тем самым мы можем перечитать данные еще раз. limit не изменяется</p>
    <h4>методы clear() and compact()</h4>
    <p>После того как мы прочитали данные из буфера его надо подготовить для записи, используя метод clean() или compact()</p>
    <p>Вызывая <b>clean()</b> position сбрасывается на 0, а limit() становится равным capacity(). На самом деле данные в буфере не очищаются, а просто переназначаются маркеры
        говорящие куда надо писать данные
    </p>
    <p>Если в буфере есть какие-либо непрочитанные данные, когда вызывается clear(), эти данные будут «забыты», что означает, что больше нет маркеров, сообщающих, какие данные были прочитаны, а какие нет</p>
    <p>Если есть непрочитанные данные, которые надо прочитать похже, то тогда лучше вызвать метод <b>compact()</b> - копирует не прочитанные данные в начало буфера, потом
        устанавливает position в значение следующее сразу за непрочитанными данными. limit устанавливается значение capacity, после этого буфер готов к записи данных без перезаписи непрочитанных данных
    </p>
    <h4>методы mark() и reset()</h4>
    <p>Можно отметить заданную позицию используя метод <b>mark()</b>, потом можно вернуться к этой позиции вызвав метод <b>reset()</b></p>
</details>
<details><summary>Java NIO Scatter / Gather (разброс и сбор данных)</summary>
    <p>Разбрасывающее чтение (scattering read) из канала - это чтение из одного канала в разные буферы</p>
    <p>Собирающая запись (gathering write) в канал - это запись данных из более чем одного буфера в один канал</p>
    <p>Это может быть полезно, когда нам надо работать с разными частями переданных данных по отдельности. Например переданные данные содержат header и body,
        и мы хотих их держать в отдельных буферах. И это облегчит работу с хедером и бади по отдельности
    </p>
    <h4>Разбрасывающее чтение (scattering read)</h4>
    <img src="https://jenkov.com/images/java-nio/scatter.png" width="30%"><br>
    <p>Пример:<br>
        ByteBuffer header = ByteBuffer.allocate(128);<br>
        ByteBuffer body   = ByteBuffer.allocate(1024);<br>
        ByteBuffer[] bufferArray = { header, body };<br>
        channel.read(bufferArray);</p>
    <p>Но такое чтение не подходит для сообщений с динамическим размером</p>
    <h4>Собирающая запись (gathering write)</h4>
    <img src="https://jenkov.com/images/java-nio/gather.png" width="30%"><br>
    <p>Пример:<br>
        ByteBuffer header = ByteBuffer.allocate(128);<br>
        ByteBuffer body   = ByteBuffer.allocate(1024);<br>
        //write data into channel<br>
        ByteBuffer[] bufferArray = { header, body };<br>
        channel.write(bufferArray);
    </p>
    <p>Создаются 2 буфера с разными размерами, в которые записывается данные. Потом создаем массив из этих буферов.
        При чем будут записаны только те данные которые расположены между указателями position и limit каждого буфера.
        Т.е. Если буфер имеет емкость 128 байт, но содержит только 58 байт, из этого буфера в канал записывается только 58 байт.
        Тем самым собирающая запись хорошо работает с динамическим сообщением, в отличаи от разбрасывающего чтения
    </p>
</details>
<details><summary>NIO Selectors</summary>
    <a href="https://javascopes.com/java-nio-selector-53c17d2f/">Введение в селектор Java NIO</a><br>
    <a href="https://github.com/andrew-savich/course/tree/master/Streams/src/main/java/com/epam/streams/theory/nio/selectors">Пример сервер-клиент на NIO</a><br>
    <p><b>Селекторы</b> обеспечивают механизм для мониторинга одного или нескольких каналов и распознавания когда эти каналы доступны для передачи данных</p>
    <p>Таким образом, один поток может управлять несколькими каналами и, следовательно, например несколькими сетевыми соединениями</p>
    <p>Используя только один поток мы можем работать с несколькими каналами, переключаясь между ними, тк использование нескольких потоков, более "энергозатратно" для ОС
        и каждый поток требует выделение памяти
    </p>
    <img src="https://jenkov.com/images/java-nio/overview-selectors.png" width="30%"><br>
    <h4>Создание Селектора:</h4>
    <p>Selector selector = Selector.open();</p>
    <h4>Регистрация каналов в селекторе:</h4>
    <p>Чтобы использовать канал с селектором, надо зарегистрировать канал в селекторе<br>
        channel.configureBlocking(false);<br>
        SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
    </p>
    <p>Канал должен быть в неблокирующем режиме для работы с селектором. По этому нельзя использовать FileChannel с селекторами,
        т.к. FileChannel не поддерживает неблокирующий режим
    </p>
    <p>Второй параметр в методе register() - это параметр интереса, т.е. какое событие нам интересно для прослушивания на этом канале</p>
    <ol>
        <li><b>Connect</b> - SelectionKey.OP_CONNECT - канал, который успешно подключился к другому серверу, «готов к подключению»</li>
        <li><b>Accept</b> - SelectionKey.OP_ACCEPT - канал сокета сервера, который принимает входящее соединение, готов к "принятию"</li>
        <li><b>Read</b> - SelectionKey.OP_READ - SelectionKey.OP_WRITE - rанал с данными, готовыми к чтению, готов к "чтению"</li>
        <li><b>Write</b> - SelectionKey.OP_WRITE - rанал, который готов для записи в него данных, готов к "записи"</li>
    </ol>
    <p>Канал, который «запускает событие», также считается «готовым» к этому событию.</p>
    <p>При регистрации канала с помощью селектора, мы получаем объект <b>SelectionKey</b> - этот объект содержит данные зарегистрированного канала:
        <ul>
            <li><b>Interest Set</b> - набор интересов представляет собой набор событий, за которыми следит селектор на канале
                представляет собой целочисленное значение. Получаем с помощью метода <b>interestOps()</b>. Пример:<br>
                int interestSet = selectionKey.interestOps();<br><br>
                boolean isInterestedInAccept = interestSet & SelectionKey.OP_ACCEPT;<br>
                boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;<br>
                boolean isInterestedInRead = interestSet & SelectionKey.OP_READ;<br>
                boolean isInterestedInWrite = interestSet & SelectionKey.OP_WRITE;<br><br>
                Когда мы делаем логическую операцию И (AND(&)) мы получаем логическое значение, которое нам говорит отслеживается событие или нет
            </li>
            <li><b>Ready Set</b> - набор "готовностей", который определяет набор событий, к которым готов канал. Получаем с помощью метода <b>readyOps()</b>. Это целочисленное значение.
                Узнать о готовности канала, можно 2мя способами, первый по аналогии с Набором интересов, произвести логические операции AND(И) с константами SelectionKey,
                или вызвав соответствующие методы:<br>
                selectionKey.isAcceptable();<br>
                selectionKey.isConnectable();<br>
                selectionKey.isReadable();<br>
                selectionKey.isWriteable();<br>
            </li>
            <li><b>Канал</b> - можно получить просматриваемый канал из объекта selectionKey:<br>
                Channel channel = key.channel();
            </li>
            <li><b>Селектор</b> - так же можно получить селектор канала:<br>
                Selector selector = key.selector();
            </li>
            <li><b>Attached Objects</b> - можно прикрепить объект к selection key. Например задать каналу кастомеый ID ёили любой другой объект Java
                <ol>Способы прикрепления объекта:
                    <li>
                        key.attach(Object);<br>
                        Object object = key.attachment();
                    </li>
                    <li>и во время регистрации канала:<br>
                        SelectionKey key = channel.register(selector, SelectionKey.OP_ACCEPT, object);
                    </li>
                </ol>
            </li>
        </ul>    
    </p>
    <h4>Выбор канала с помощью селектора:</h4>
    <p>После того, как зарегистрировали один или несколько каналов с помощью Selector, можно вызвать один из методов select().
        Эти методы возвращают каналы, которые «готовы» к интересующим вас событиям (подключение, принятие, чтение или запись).  
        Другими словами, если интересуют каналы, готовые к чтению, получаем готовые к чтению каналы из методов select().
    </p>
    <ul>Методы:
        <li><b>int select()</b> - блокируется до тех пор, пока хотя бы один канал не будет готов к событиям, на которые вы зарегистрировались</li>
        <li><b>int select(long timeout)</b> - блокируется на максимальное время ожидания в миллисекундах</li>
        <li><b>int selectNow()</b> - вообще не блокирует. Он немедленно возвращается с любыми готовыми каналами.</li>
    </ul>
    <p>Пример:<br>
        int channels = selector.select();<br>
        Этот метод блокирует до тех пор, пока хотя бы один канал не будет готов к операции. Возвращаемое целое число представляет собой количество ключей, каналы которых готовы к операции.<br>
        После того, как был вызван один из методов select(), его возвращаемое значение указывало, что один или несколько каналов готовы,
        можно получить доступ к готовым каналам через «выбранный набор ключей», вызвав метод selectedKeys():<br>
        Set	&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>
        Полученный набор состоит из объектов SelectionKey, каждый ключ представляет собой зарегистрированный канал, который готов к работе
    </p>
    <p>После этого мы обычно перебираем этот набор и для каждого ключа получаем канал и выполняем над ним любые операции, которые появляются в нашем наборе интересов</p>
</details>
<br>
<details><summary>В каких ситуациях использовать IO, а когда NIO</summary>
    <p>Выбор IO или NIO обусловлен конкретными бизнес задачами</p>
    <ul>NIO
        <li>Если нам надо более гибкая обработка получаемых/отправляемых данных</li>
        <li>Если надо управлять большим количеством стримов одновременно, которые передают небольшие объемы данных</li>
    </ul>
    <ul>IO
        <li>Когда надо последовательная обработка передаваемых данных или "всё сразу и целиком"</li>
        <li>Когда у нас меньшее количество стримов, и большие объемы передоваемых данных</li>
    </ul>
</details>
