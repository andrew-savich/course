<details><summary>Что такое и какая главная причина использования аннотаций?</summary>
    <p><b>Аннотация</b> - средство, позволяющее встраивать справочную информацию в исходные файлы.</p>
    <p>Эта информация может использоваться различными средствами на стадии разработки или развертывания программы.
        Например, аннотация может обрабатываться генераторами исходного кода
    </p>
    <ul>Функции аннотации
        <li>даёт дополнительную информацию для компилятора</li>
        <li>даёт информацию различным инструментам для генерации другого кода, конфигураций и т. д.</li>
        <li>может использоваться во время выполнения для получения данных через отражение (reflection)</li>
    </ul>
</details>

<details><summary>Популярные аннотации Java (по типу выполнения)?</summary>
    <ul>
        <li>Аннотации для аннотаций или мета-аннотациями</li>
        <li>Аннотации типов</li>
        <li>Аннотации для кода</li>
        <li>Нативные аннотации</li>
        <li>Аннотации, написанные программистом</li>
    </ul>
</details>

<details><summary>Аннотации для аннотаций</summary>
    <ul>
        <li><b>@Target</b> - указывает контекст, для которого применима аннотация
            <ul>
                <li><b>ElementType.ANNOTATION_TYPE</b> - применяется для определения другой аннотации</li>
                <li><b>ElementType.CONSTRUCTOR</b> - применяется для определения конструктора</li>
                <li><b>ElementType.FIELD</b> - применяется для определения поля, включая константы Enum</li>
                <li><b>ElementType.LOCAL_VARIABLE</b> - применяется для определения локальной переменной</li>
                <li><b>ElementType.METHOD</b> - применяется для определения метода</li>
                <li><b>ElementType.MODULE</b> - применяется для определения модуля (с Java 9)</li>
                <li><b>ElementType.PACKAGE</b> - применяется для определения пакета</li>
                <li><b>ElementType.PARAMETER</b> - применяется для определения параметра</li>
                <li><b>ElementType.TYPE</b> - применяется для определения класса, интерфейса (включая аннотируемый тип), Enum или record</li>
                <li><b>ElementType.TYPE_PARAMETER</b> - применяется для определения типа параметра (с Java 8)</li>
                <li><b>ElementType.TYPE_USE</b> - применяется для определения используемого типа (с Java 8)</li>
                <li><b>ElementType.RECORD_COMPONENT</b> - ассоциируется с records как компонент записи (с Java 14)</li>
            </ul>
        </li>
        <li><b>@Retention</b> - указывает, до какого шага во время компиляции аннотация будет доступна
            <ul>
                <li><b>RetentionPolicy.SOURCE</b> - аннотация сохраняется только в исходном файле и удаляется во время компиляции</li>
                <li><b>RetentionPolicy.CLASS</b> - аннотация сохраняется в файле .class во время компиляции, но недоступна во время выполнения через JVM</li>
                <li><b>RetentionPolicy.RUNTIME</b> - аннотация сохраняется в файле .class во время компиляции и доступна через JVM во время выполнения</li>
            </ul>
            <p>По умолчанию будет использована политика RetentionPolicy.CLASS</p>
        </li>
        <li><b>@Documented</b> - указывает, что аннотация должна быть задокументирована с помощью javadoc</li>
        <li><b>@Inherited</b> - позволяет реализовать наследование аннотаций родительского класса классом-наследником</li>
        <li><b>@Repeatable</b> - указывает, что аннотация может быть использована повторно в том же месте</li>
    </ul>
</details>

<details><summary>Аннотации для кода</summary>
    <ul>
        <li><b>@Override</b> - указывает, что метод переопределяет, объявленный в суперклассе или интерфейсе метод</li>
        <li><b>@Deprecated</b> - помечает код, как устаревший</li>
        <li><b>@SuppressWarnings</b> - отключает для аннотированного элемента предупреждения компилятора. Обратите внимание, что если необходимо отключить 
            несколько категорий предупреждений, их следует добавить в фигурные скобки, например @SuppressWarnings ({"unchecked", "cast"})
        </li>
        <li><b>@SafeVarargs</b> - отключает предупреждения для всех методов или конструкторов, принимающих в качестве параметра varargs</li>
        <li><b>@FunctionalInterface</b> - помечает интерфейсы, имеющие только один абстрактный метод (при этом они могут содержать любое 
            количество методов по умолчанию или статических)
        </li>
    </ul>
</details>

<details><summary>Что можно аннотировать</summary>
    <p>классы, методы, поля, параметры, константы перечисления, сами аннотации</p>
    <p>С помощью аннотации <b>@Target</b> мы указываем что будем помечать. Пример:<br>
        @Target(value=ElementType.METHOD)</p>
</details>

<details><summary>Правила удержания аннотаций</summary>
    <p>Правила удержания определяют момент, когда аннотация отбрасывается</p>
    <ul>Определены три правила, инкапсулированные в перечислении java.lang.annotation.RetentionPolicy:
        <li><b>SOURCE</b> - хранятся только в исходном файле и отбрасываются при компиляции</li>
        <li><b>CLASS</b> - сохраняются в файле с расширением .class во время компиляции</li>
        <li><b>RUNTIME</b> - сохраняются в файле с расширением .class во время компиляции и остаются доступными для 
            виртуальной машины JVM во время выполнения
        </li>
    </ul>
    <p>Правило удержания аннотации задается с помощью одной из встроенных аннотаций Java: @Retention</p>
</details>

<details><summary>Что Такое Повторяющиеся Аннотации? И зачем они нам?</summary>
    <p>Начиная с версии Java 8 появилась возможность повторного использования аннотации, с помощью аннотации <b>@Repeatable</b><br>
        Для этого в Repeatable  в поле Value надо указать аннотацию контейнер. Например есть аннотация Day которая будет использоваться повторно<br>
        и будет аннотация контейнер Days, у которой будет value типа Day[]. И тогда над аннотацией Day надо указать @Repaetable(Days.class)
    </p>
</details>

<details><summary>Наследование в аннотациях?</summary>
    <p>По умолчанию аннотации примененные к родительскому классу не будут доступны в наследуемом классе.
        для того чтоб они были доступны в классах наследниках, надо применить аннотацию <b>@Inherited</b>
    </p>
    <p>Аннотация, как класс или интерфейс представляется в системе ссылочным типом, она тоже компилируется в .class-файл.
        Вы можете создать переменную с типом, скажем, java.lang.Override. Но в отличие от других ссылочных типов, 
        объявление аннотации (@interface) не может иметь секций extends или implements. Это ограничение добавлено просто 
        чтобы не усложнять систему типов. В скомпилированном коде все типы-аннотации – это интерфейсы, унаследованные от Annotation
    </p>
</details>

<details><summary>Правила определения полей (параметров) в аннотациях</summary>
    <ul>
        <li>параметр описывается как функция (с круглыми скобками) но без фигурных скобок</li>
        <li>могут быть использованы только примитивы, String, Enum, тип аннотации</li>
        <li>Могут иметь стандартное значение которое задается после ключ. слова default</li>
        <li>Могут быть массивом</li>
    </ul>    
</details>

<details><summary>value в аннотациях</summary>
    <p>Если объявить атрибут с именем value, то его можно опускать при использовании</p>
</details>

<details><summary>Какие типы могут возвращать поля определенные в аннотациях?</summary>
    <ul>
        <li>примитивные типы данных</li>
        <li>String</li>
        <li>примитивные типы данных</li>
        <li>enum</li>
        <li>тип другой аннотации</li>
        <li>Class</li>
        <li>массив любого из вышеуказанного типа</li>
    </ul>
</details>

<details><summary>Инструкции выполнения аннотаций (по типу выполнения)</summary>
    <p>Мета-аннотация Retention позволяет определить жизненный цикл аннотации, т.е. будет она присутствовать только в 
        исходном коде, в скомпилированном файле, или она будет видна и в процессе выполнения... Выбор нужного типа 
        аннотации @Retention зависит от того, как будет использоваться данная аннотацию, например будет ли она 
        генерировать что-то из исходного кода, или в процессе выполнения к ней можно будет получить доступ с помощью 
        рефлексии. Для этого используется 3 типа: RetentionPolicy.SOURCE (доступна в исходном коде), 
        RetentionPolicy.CLASS(в скомпилированном классе), RetentionPolicy.RUNTIME(во время выполнения)
    </p>
    <p>что хочется сказать по поводу использования аннотаций, то их используют какие-то обработчики аннотаций, т.е. 
        системы или приложения, которые используют аннотированный код и выполняют различные действия в зависимости от 
        информации аннотаций, например: в случае встроенных аннотаций, которые поставляются из коробки со стандартной 
        Java, обработчиком является JVM... JUnit Обрабатывает методы помеченные своей аннотацией @Test, Spring fram. 
        элементы помечяенные своими аннотациями @Bean, @Autowired и тд
    </p>
</details>

<details><summary>Примеры использования</summary>
    <p><b>SOURCE:</b> когда нам надо сделать проверку, во время компиляции, на примере с аннотацией @Override которая 
        нам говорит, обрати внимание, ты плохо переопределил метод, например указав не все параметры метода или 
        другая кака-нибудь причина, типо такого метода нет в реализуемом тобой интерфейсе
    </p>
    <p><b>RUNTIME:</b> когда нам нужно произвести какие то монипуляции (сгенерировать код, получить данные) используя 
        рефлексию во время выполнения, чем пользуются фреймворки... вот Ломбок увидел свою аннотацию @Setter и 
        сгенерировал сеттеры для полей класса в которых они определены
    </p>
    <p><b>CLASS:</b> используется реже всего, но установлена как значение по умолчанию... используется для 
        парссеров/анализаторов/агентов байт кода, которые в свою очередь могут производить какие то действия, 
        но мы не хотим открывать доступ для рефлексии. В байткоде аннготация помеченная этой политикой будет 
        invisible, а для RUNTIME аннотации этот параметр будет visible
    </p>
</details>