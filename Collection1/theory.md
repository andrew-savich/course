<details><summary>Что такое коллекции и зачем они нам нужны?</summary>
    <p>Это структура данных, способная хранить в себе однотипные элементы, имеющая методы для обработки этих данных</p>
</details>

<details><summary>Иерархия коллекций</summary>
    <img src="https://highload.today/wp-content/uploads/2021/08/image8-3.png" width="70%">
</details>

<details><summary>Почему map не является частью коллекций</summary>
    <p>Разные структуры данных: List, Set, Queue - набор объектов одного типа. Map - набор пар Ключ-Значение</p>
    <p>List, Set, Queue имеют метод add, который принимает значение в качестве параметра для его добавления.<br>
    Map имеют метод put - который принимает параметры в виде ключ-значение для их добавления </p>
    <p>List, Set и Queue обеспечивают итерацию по значению, тогда как Map имеет 
        ключи для итерации, которые в конечном итоге представляют собой Set и Values as Collection.</p>
</details>

<details><summary>Интерфейс Collection?</summary>
    <p>Это обобщенный интерфейс служит основанием, на котором построен весь каркас коллекций, поскольку он должен быть реализован всеми классами коллекций.</p>
    <p>Collection расширяет интерфейс Iterable. Это означает, что все коллекции можно перебирать, организовав цикл for each</p>
    <p>В интерфейсе Collection определяются основные методы, которые должны иметь все коллекции:<br>
    add, addAll, clear, contains, containsAll, equals, hashCode, isEmpty, iterator, remove, removeAll, retainAll, size, stream, toArray</p>
</details>

<details><summary>Стоимость операций коллекций? (Правило большого O)</summary>
    <p>При расчёте O большого мы должны исходить из худшего возможного варианта</p>
    <p>Удаление констант. Малоемкие операции, выполняющиеся за константное время (объявление переменной и тд) - опускаются</p>
    <p>Предоставление переменных с разными именами для отдельных входных данных</p>
    <p>Отбрасывание всех терминов, которые не являются доминирующими в вашем алгоритме</p>
    <a href="https://dev.to/coderjay06/four-rules-for-big-o-1915">Four Rules for Big O</a>
</details>

<details><summary>Способы перебора коллекций?</summary>
    <a href="https://juja.com.ua/java/java-collections/iterate-arraylist-java/">ArrayList — 8 способов итерации в Java</a>
    <p>Обычный цикл for</p> 
    <p>Цикл for each</p>
    <p>Цикл for с итератором</p>
    <p>Цикл while с итератором</p>
    <p>JDK 8: стрим с лямбда выражением</p>
    <p>JDK 8: стрим с ссылкой на метод</p>
    <p>JDK 8: Цикл for each с лямбда выражением</p>
    <p>JDK 8: Цикл for each с ссылкой на метод</p>
</details>

<details><summary>Способы перебора Мар?</summary>
    <a href="https://invest-map-nnov.com/different-ways-iterate-through-map-java">Различные способы перебора карты в Java</a>
    <p>В цикле for each использовать Map.entry в качестве элемента пробегая по myMap.entrySet(), и для получения ключа entry.getKey(), значения: entry.getValue()</p>
    <p>В цикле for each перебрать ключи myMap.keySet()</p>
    <p>В цикле for each перебрать ключи myMap.values()</p>
    <p>С помощью итератора: Iterator entries = map.entrySet().iterator(); while(entries.hasNext()) {Map.Entry entry = entries.next(); entry.getKey(); entry.getValue();}</p>
    <p>JDK 8 forEach: myMap.forEach((k,v)->System.out.println('Key : ' + k + ' Value : ' + v));</p>
</details>

<details><summary>Что такое итератор, применимо к коллекциям?</summary>
    <p>Iterator - можно перевести как переборщик. Это сущность, способная перебрать все элементы в коллекции. При этом она позволяет это сделать без
    вникания во внутреннюю структуру и устройство коллекций</p>
    <ul>Действия при работе с Iterator:
        <li>Получите итератор в начале коллекции, вызвав метод iterator() коллекции</li>
        <li>Настройте цикл, который вызывает hasNext(). Повторяйте цикл, пока hasNext() возвращает true</li>
        <li>Внутри цикла получите каждый элемент, вызывая next()</li>
    </ul>
    <ul>Методы:
        <li>boolean hasNext()</li>
        <li>E next()</li>
        <li>void remove()</li>
        <li>default void forEachRemaining(Consumer<? super Е> action)</li>
    </ul>
    <p>iterator для List — самая распространенная имплементация. Итератор идет от начала коллекции к ее концу: смотрит есть ли в наличии следующий элемент 
        и возвращает его, если таковой находится. На основе этого несложного алгоритма построен цикл for-each</p>
    <a href="https://javarush.ru/groups/posts/1884-pattern-iterator">Паттерн Iterator</a>
</details>

<details><summary>Fail safe vs Fail fast?</summary>
    <p>Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет</p>
    <p><b>Fail-fast (безотказный)</b> – «быстрый» итератор. Когда после его создания коллекция как-либо изменилась, он падает с ошибкой без лишних разбирательств.
    Так работает итератор класса ArrayList, при изменении он выбрасывает ConcurrentModificationException.</p>
    <p><b>Fail-safe (отказоустойчивый)</b> – «умный» итератор. Обычно плата за отказоустойчивость – возможная неконсистентность данных («слабая консистентность»).
    Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений.</p>
    <a href="https://javarush.ru/groups/posts/399-skaz-o-dvukh-iteratorakh-strategii-konkurentnoy-modifikacii-v-java-">Сказ о двух итераторах: стратегии конкурентной модификации в Java</a>
</details>

<details><summary>Лист итератор?</summary>
    <p>Интерфейс ListIterator расширяет интерфейс Iterator и используется для двустороннего обхода списка и видоизменения его элементов.</p>
    <p>ListIterator можно получить вызывая метод listIterator() для коллекций, реализующих List.</p>
    <ul>Методы
        <li><b>void add(Е obj)</b> - вставляет obj перед элементом, который должен быть возвращен следующим вызовом next()</li>
        <li><b>boolean hasNext()</b> - возвращает true, если есть следующий элемент. В противном случае возвращает false</li>
        <li><b>boolean hasPrevious()</b> - возвращает true, если есть предыдущий элемент. В противном случае возвращает false</li>
        <li><b>Е next()</b> - возвращает следующий элемент. Если следующего нет, инициируется исключение NoSuchElementException</li>
        <li><b>int nextIndex()</b> - возвращает индекс следующего элемента. Если следующего нет, возвращается размер списка.</li>
        <li><b>Е previous()</b> - возвращает предыдущий элемент. Если предыдущего нет, инициируется исключение NoSuchElementException</li>
        <li><b>int previousIndex()</b> - возвращает индекс предыдущего элемента. Если предыдущего нет, возвращается -1</li>
        <li><b>void remove()</b> - удаляет текущий элемент из списка. Если remove() вызван до next() или previous(), инициируется исключение IllegalStateException</li>
        <li><b>void set(Е obj)</b> - присваивает obj текущему элементу. Это элемент, возвращенный последним вызовом next() или previous()</li>
    </ul>
</details>

<details><summary>Iterator vs listIterator?</summary>
    <p>ListIterator расширяет Iterator, чтобы обеспечить двунаправленный обход списка и модификацию элементов</p>
    <p>ListIterator есть возможность добавления элементов</p>
    <p>ListIterator есть возможность удаления элементов</p>
    <p>ListIterator работает только с реализациями List, а Iterator может работать и с Set, Map</p>
    <p>Возможность получить индекс элемента с помощью Iterator. Но поскольку список является последовательным и основан на индексах, вы можете получить индекс элемента с помощью ListIterator</p>
</details>

<details><summary>Enumeration?</summary>
    <p>Интерфейс Enumeration – определяет методы, с помощью которых можно перечислить (получить по одному) элементы в коллекции объектов</p>
    <p>Этот устаревший интерфейс был заменён Iterator. Хоть и не совсем, но Enumeration в Java считается устаревшим для нового кода. Однако он используется некоторыми методами, определёнными такими устаревшими классами, как Vector и Properties,
    используется другими API классами и сейчас широко используется в коде приложений.</p>
    <ul>Методы:
        <li><b>boolean hasMoreElements()</b> - возвращает true, если существуют элементы для извлечения, и false, когда все элементы были перечислены</li>
        <li><b>E nextElement()</b> - возвращает следующий объект в перечислении</li>
    </ul>
</details>

<details><summary>Итератор полученный из набора Set?</summary>
    Iterator iterator = mySet.iterator();<br>
    while (iterator.hasNext()) {<br>
    //do something with iterator.next()<br>
}
</details>

<details><summary>Comparable vs Comparator?</summary>
    <p><b>Comparable (сравнимый)</b> - объекты класса реализующего этот интерфейс можно сравнивать. Реализуя метод <b>int compareTo(T o)</b></p>
    <ul>compareTo(T o) возвращает int:
        <li>ноль, если два объекта равны</li>
        <li>число &gt; 0, если первый объект (на котором вызывается метод) больше, чем второй (который передается в качестве параметра)</li>
        <li>число &lt; 0, если первый объект меньше второго</li>
    </ul>
    <p><b>Comparator</b> - интерфейс для реалиации нестандартной сортировки. Является внешним по отношению к сравниваемому типу элемента. Это отдельный класс.
    Мы создаем несколько отдельных классов (которые реализуют Comparator) для сравнения по разным членам.</p>
    <ul>Чтоб им воспользоваться нужно проделать следующие шаги:
        <li>Создать класс, реализующий метод compare(), интерфейса Comparator, по аналогии как метод compareTo интерфейса Comparable</li>
        <li>Создать экземпляр этого класса</li>
        <li>Вызвать метод Collections.sort(list, myCompare), которому передать сортируемую коллекцию и экземпляр нашего компаратора</li>
    </ul>
    <ul>Выбор между Cpmparable и Comparator:
        <li>Comparable предназначен для объектов с естественным порядком, что означает, что сам объект должен знать, как его упорядочить</li>
        <li>Логически интерфейс Comparable сравнивает «эту» ссылку с указанным объектом, а Comparator в Java сравнивает два разных предоставленных объекта класса</li>
        <li>Если какой-либо класс реализует интерфейс Comparable в Java, то коллекция этого объекта, либо List, либо Array, может быть отсортирована автоматически с 
            помощью метода Collections.sort() или Arrays.sort(), а объекты будут отсортированы на основе естественного порядка, определенного методом CompareTo.
        </li>
        <li>Основная отличительная черта заключается в том, что при использовании сравнения мы можем использовать только одно сравнение.
            Принимая во внимание, что мы можем написать более одного пользовательского компаратора, как вы хотите, для данного типа, используя 
            разные интерпретации того, что означает сортировка.
        </li>
    </ul>
    <p>Подводя итог, если сортировка объектов должна быть основана на естественном порядке, используйте Comparable, тогда как если вам необходимо 
        выполнить сортировку по атрибутам разных объектов, используйте Comparator в Java.
    </p>
</details>

<details><summary>Рассмотреть immutable collections? Зачем нам и в каких ситуациях использовать?</summary>
    <p>Объект считается неизменяемым, если его состояние не может измениться после его создания. После создания неизменяемого экземпляра коллекции он содержит 
        одни и те же данные, пока существует ссылка на него.
    </p>
    <p>В JDK 9 были добавлены удобные статические фабричные методы в интерфейсах List, Set и Map, которые, позволяют легко создавать immutable lists, maps, sets</p>
    <ul>
        <li>List.of()</li>
        <li>Set.of()</li>
        <li>Map.of()</li>
    </ul>
    <p>Коллекции, созданные с помощью этих методов, содержат неизменяемые объекты, то после создания они автоматически становятся потокобезопасными.</p>
    <p>Коллекции, возвращаемые удобными фабричными методами, добавленными в JDK 9, обычно неизменяемы. Любая попытка добавить, установить или удалить элементы из этих коллекций приводит к возникновению исключения UnsupportedOperationException.</p>
    <p>Можно использовать в тех случаях, когда у нас есть известный набор данных, который не будет изменяться. Так же неизменяемые коллекции 
    предоставляют более высокую производительность и потокобезопастность </p>
</details>

<details><summary>Mutable vs Immutable</summary>
    <ul>Приемущества изменяемых коллекций
        <li>Более эффективно используют память</li>
        <li>Потокобезопастность, НО Коллекция считается неизменяемой, если элементы нельзя добавлять, удалять или заменять. 
            Однако неизменяемая коллекция является неизменной только в том случае, если элементы, содержащиеся в коллекции, 
            неизменны. Чтобы считаться потокобезопасным, коллекции, созданные с использованием статических фабричных методов 
            и сборщиков toUnmodifying-, должны содержать только неизменяемые элементы
        </li>
    </ul>
</details>

<details><summary>Сортировка коллекций?</summary>
    <a href="https://academy.yandex.ru/posts/osnovnye-vidy-sortirovok-i-primery-ikh-realizatsii">Основные виды сортировок и примеры их реализации</a>
    <ul>Виды:
        <li><b>Пузырьком</b> - нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. 
                                Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.
            <ul>
                <li>Худшее время: O(n^2)</li>
                <li>Среднее время: O(n^2)</li>
                <li>Лучшее время: O(n)</li>
            </ul>
        </li>
        <li><b>Перемешиванием (шейкерная сортировка)</b> - Шейкерная сортировка отличается от пузырьковой тем, что она двунаправленная: алгоритм перемещается 
            не строго слева направо, а сначала слева направо, затем справа налево.
            <ul>
                <li>Худшее время: O(n^2)</li>
                <li>Среднее время: O(n^2)</li>
                <li>Лучшее время: O(n)</li>
            </ul>
        </li>
        <li><b>Расчёской</b> - улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, 
            которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, 
            то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.
            <ul>
                <li>Худшее время: O(n^2)</li>
                <li>Среднее время: O(n^2)</li>
                <li>Лучшее время: O(n logn)</li>
            </ul>
        </li>
        <li><b>Быстрая</b> - Этот алгоритм состоит из трёх шагов. Сначала из массива нужно выбрать один элемент — его обычно называют опорным. Затем другие 
            элементы в массиве перераспределяют так, чтобы элементы меньше опорного оказались до него, а большие или равные — после. А дальше рекурсивно 
            применяют первые два шага к подмассивам справа и слева от опорного значения.
            <ul>
                <li>Худшее время: O(n^2)</li>
                <li>Среднее время: O(n logn)</li>
                <li>Лучшее время: O(n)</li>
            </ul>
        </li>
        <li><b>Слияние</b> - пригодится для таких структур данных, в которых доступ к элементам осуществляется последовательно (например, для потоков). 
            Здесь массив разбивается на две примерно равные части и каждая из них сортируется по отдельности. Затем два отсортированных подмассива сливаются в один.
            <ul>
                <li>Худшее время: O(n logn)</li>
                <li>Среднее время: O(n logn)</li>
                <li>Лучшее время: O(n logn)</li>
            </ul>
        </li>
    </ul>
    <p>Но на данный момент лучше не писать в ручную сортировку, тк лучшие варианты уже написаны до нас</p>
    <ul>Для сортировки
        <li>Коллекции: Collections.sort()</li>
        <li>Массива: Arrays.sort()</li>
        <li>Set: TreeSet</li>
        <li>Map: TreeMap</li>
    </ul>
</details>

