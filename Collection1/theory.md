<details><summary>Что такое коллекции и зачем они нам нужны?</summary>
    <p>Это структура данных, способная хранить в себе однотипные элементы, имеющая методы для обработки этих данных</p>
</details>

<details><summary>Иерархия коллекций</summary>
    <img src="https://highload.today/wp-content/uploads/2021/08/image8-3.png" width="70%">
</details>

<details><summary>Почему map не является частью коллекций</summary>
    <p>Разные структуры данных: List, Set, Queue - набор объектов одного типа. Map - набор пар Ключ-Значение</p>
    <p>List, Set, Queue имеют метод add, который принимает значение в качестве параметра для его добавления.<br>
    Map имеют метод put - который принимает параметры в виде ключ-значение для их добавления </p>
    <p>List, Set и Queue обеспечивают итерацию по значению, тогда как Map имеет 
        ключи для итерации, которые в конечном итоге представляют собой Set и Values as Collection.</p>
</details>

<details><summary>Интерфейс Collection?</summary>
    <p>Это обобщенный интерфейс служит основанием, на котором построен весь каркас коллекций, поскольку он должен быть реализован всеми классами коллекций.</p>
    <p>Collection расширяет интерфейс Iterable. Это означает, что все коллекции можно перебирать, организовав цикл for each</p>
    <p>В интерфейсе Collection определяются основные методы, которые должны иметь все коллекции:<br>
    add, addAll, clear, contains, containsAll, equals, hashCode, isEmpty, iterator, remove, removeAll, retainAll, size, stream, toArray</p>
</details>

<details><summary>Стоимость операций коллекций? (Правило большого O)</summary>
    <p>При расчёте O большого мы должны исходить из худшего возможного варианта</p>
    <p>Удаление констант. Малоемкие операции, выполняющиеся за константное время (объявление переменной и тд) - опускаются</p>
    <p>Предоставление переменных с разными именами для отдельных входных данных</p>
    <p>Отбрасывание всех терминов, которые не являются доминирующими в вашем алгоритме</p>
    <a href="https://dev.to/coderjay06/four-rules-for-big-o-1915">Four Rules for Big O</a>
</details>

<details><summary>Способы перебора коллекций?</summary>
    <a href="https://juja.com.ua/java/java-collections/iterate-arraylist-java/">ArrayList — 8 способов итерации в Java</a>
    <p>Обычный цикл for</p> 
    <p>Цикл for each</p>
    <p>Цикл for с итератором</p>
    <p>Цикл while с итератором</p>
    <p>JDK 8: стрим с лямбда выражением</p>
    <p>JDK 8: стрим с ссылкой на метод</p>
    <p>JDK 8: Цикл for each с лямбда выражением</p>
    <p>JDK 8: Цикл for each с ссылкой на метод</p>
</details>

<details><summary>Способы перебора Мар?</summary>
    <a href="https://invest-map-nnov.com/different-ways-iterate-through-map-java">Различные способы перебора карты в Java</a>
    <p>В цикле for each использовать Map.entry в качестве элемента пробегая по myMap.entrySet(), и для получения ключа entry.getKey(), значения: entry.getValue()</p>
    <p>В цикле for each перебрать ключи myMap.keySet()</p>
    <p>В цикле for each перебрать ключи myMap.values()</p>
    <p>С помощью итератора: Iterator entries = map.entrySet().iterator(); while(entries.hasNext()) {Map.Entry entry = entries.next(); entry.getKey(); entry.getValue();}</p>
    <p>JDK 8 forEach: myMap.forEach((k,v)->System.out.println('Key : ' + k + ' Value : ' + v));</p>
</details>

<details><summary>Что такое итератор, применимо к коллекциям?</summary>
    <p>Iterator - можно перевести как переборщик. Это сущность, способная перебрать все элементы в коллекции. При этом она позволяет это сделать без
    вникания во внутреннюю структуру и устройство коллекций</p>
    <ul>Действия при работе с Iterator:
        <li>Получите итератор в начале коллекции, вызвав метод iterator() коллекции</li>
        <li>Настройте цикл, который вызывает hasNext(). Повторяйте цикл, пока hasNext() возвращает true</li>
        <li>Внутри цикла получите каждый элемент, вызывая next()</li>
    </ul>
    <ul>Методы:
        <li>boolean hasNext()</li>
        <li>E next()</li>
        <li>void remove()</li>
        <li>default void forEachRemaining(Consumer<? super Е> action)</li>
    </ul>
    <p>iterator для List — самая распространенная имплементация. Итератор идет от начала коллекции к ее концу: смотрит есть ли в наличии следующий элемент 
        и возвращает его, если таковой находится. На основе этого несложного алгоритма построен цикл for-each</p>
    <a href="https://javarush.ru/groups/posts/1884-pattern-iterator">Паттерн Iterator</a>
</details>

<details><summary>Fail safe vs Fail fast?</summary>
    <p>Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет</p>
    <p><b>Fail-fast (безотказный)</b> – «быстрый» итератор. Когда после его создания коллекция как-либо изменилась, он падает с ошибкой без лишних разбирательств.
    Так работает итератор класса ArrayList, при изменении он выбрасывает ConcurrentModificationException.</p>
    <p><b>Fail-safe (отказоустойчивый)</b> – «умный» итератор. Обычно плата за отказоустойчивость – возможная неконсистентность данных («слабая консистентность»).
    Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений.</p>
    <a href="https://javarush.ru/groups/posts/399-skaz-o-dvukh-iteratorakh-strategii-konkurentnoy-modifikacii-v-java-">Сказ о двух итераторах: стратегии конкурентной модификации в Java</a>
</details>

<details><summary>Лист итератор?</summary>
    <p>Интерфейс ListIterator расширяет интерфейс Iterator и используется для двустороннего обхода списка и видоизменения его элементов.</p>
    <p>ListIterator можно получить вызывая метод listIterator() для коллекций, реализующих List.</p>
    <ul>Методы
        <li><b>void add(Е obj)</b> - вставляет obj перед элементом, который должен быть возвращен следующим вызовом next()</li>
        <li><b>boolean hasNext()</b> - возвращает true, если есть следующий элемент. В противном случае возвращает false</li>
        <li><b>boolean hasPrevious()</b> - возвращает true, если есть предыдущий элемент. В противном случае возвращает false</li>
        <li><b>Е next()</b> - возвращает следующий элемент. Если следующего нет, инициируется исключение NoSuchElementException</li>
        <li><b>int nextIndex()</b> - возвращает индекс следующего элемента. Если следующего нет, возвращается размер списка.</li>
        <li><b>Е previous()</b> - возвращает предыдущий элемент. Если предыдущего нет, инициируется исключение NoSuchElementException</li>
        <li><b>int previousIndex()</b> - возвращает индекс предыдущего элемента. Если предыдущего нет, возвращается -1</li>
        <li><b>void remove()</b> - удаляет текущий элемент из списка. Если remove() вызван до next() или previous(), инициируется исключение IllegalStateException</li>
        <li><b>void set(Е obj)</b> - присваивает obj текущему элементу. Это элемент, возвращенный последним вызовом next() или previous()</li>
    </ul>
</details>

<details><summary>Iterator vs listIterator?</summary>
    <p>ListIterator расширяет Iterator, чтобы обеспечить двунаправленный обход списка и модификацию элементов</p>
    <p>ListIterator есть возможность добавления элементов</p>
    <p>ListIterator есть возможность удаления элементов</p>
    <p>ListIterator работает только с реализациями List, а Iterator может работать и с Set, Map</p>
    <p>Возможность получить индекс элемента с помощью Iterator. Но поскольку список является последовательным и основан на индексах, вы можете получить индекс элемента с помощью ListIterator</p>
</details>

<details><summary>Enumeration?</summary>
    <p>Интерфейс Enumeration – определяет методы, с помощью которых можно перечислить (получить по одному) элементы в коллекции объектов</p>
    <p>Этот устаревший интерфейс был заменён Iterator. Хоть и не совсем, но Enumeration в Java считается устаревшим для нового кода. Однако он используется некоторыми методами, определёнными такими устаревшими классами, как Vector и Properties,
    используется другими API классами и сейчас широко используется в коде приложений.</p>
    <ul>Методы:
        <li><b>boolean hasMoreElements()</b> - возвращает true, если существуют элементы для извлечения, и false, когда все элементы были перечислены</li>
        <li><b>E nextElement()</b> - возвращает следующий объект в перечислении</li>
    </ul>
</details>

<details><summary>Итератор полученный из набора Set?</summary>
    Iterator iterator = mySet.iterator();<br>
    while (iterator.hasNext()) {<br>
    //do something with iterator.next()<br>
}
</details>

<details><summary>Comparable vs Comparator?</summary>
    <p><b>Comparable (сравнимый)</b> - объекты класса реализующего этот интерфейс можно сравнивать. Реализуя метод <b>int compareTo(T o)</b></p>
    <ul>compareTo(T o) возвращает int:
        <li>ноль, если два объекта равны</li>
        <li>число &gt; 0, если первый объект (на котором вызывается метод) больше, чем второй (который передается в качестве параметра)</li>
        <li>число &lt; 0, если первый объект меньше второго</li>
    </ul>
    <p><b>Comparator</b> - интерфейс для реалиации нестандартной сортировки. Является внешним по отношению к сравниваемому типу элемента. Это отдельный класс.
    Мы создаем несколько отдельных классов (которые реализуют Comparator) для сравнения по разным членам.</p>
    <ul>Чтоб им воспользоваться нужно проделать следующие шаги:
        <li>Создать класс, реализующий метод compare(), интерфейса Comparator, по аналогии как метод compareTo интерфейса Comparable</li>
        <li>Создать экземпляр этого класса</li>
        <li>Вызвать метод Collections.sort(list, myCompare), которому передать сортируемую коллекцию и экземпляр нашего компаратора</li>
    </ul>
    <ul>Выбор между Cpmparable и Comparator:
        <li>Comparable предназначен для объектов с естественным порядком, что означает, что сам объект должен знать, как его упорядочить</li>
        <li>Логически интерфейс Comparable сравнивает «эту» ссылку с указанным объектом, а Comparator в Java сравнивает два разных предоставленных объекта класса</li>
        <li>Если какой-либо класс реализует интерфейс Comparable в Java, то коллекция этого объекта, либо List, либо Array, может быть отсортирована автоматически с 
            помощью метода Collections.sort() или Arrays.sort(), а объекты будут отсортированы на основе естественного порядка, определенного методом CompareTo.
        </li>
        <li>Основная отличительная черта заключается в том, что при использовании сравнения мы можем использовать только одно сравнение.
            Принимая во внимание, что мы можем написать более одного пользовательского компаратора, как вы хотите, для данного типа, используя 
            разные интерпретации того, что означает сортировка.
        </li>
    </ul>
    <p>Подводя итог, если сортировка объектов должна быть основана на естественном порядке, используйте Comparable, тогда как если вам необходимо 
        выполнить сортировку по атрибутам разных объектов, используйте Comparator в Java.
    </p>
</details>

<details><summary>Рассмотреть immutable collections? Зачем нам и в каких ситуациях использовать?</summary>
    <p><b>ImmutableList</b> - это неизменяемый тип List. Содержимое списка является фиксированным или постоянным после объявления, т. е. доступно только для чтения</p>
    <p>При любой попытке добавить, удалить или обновить элементы в списке возникает исключение UnsupportedOperationException</p>
    <p>ImmutableList также не допускает null</p>
    <p>При любой попытке создать ImmutableList с нулевым элементом создается исключение NullPointerException. Если делается какая-либо 
        попытка добавить нулевой элемент в список, генерируется исключение UnsupportedOperationException
    </p>
    <ul>преимущества:
        <li>Потокобезопасность</li>
        <li>Эффективное использование памяти</li>
    </ul>
</details>

<details><summary>Mutable vs Immutable</summary>
    <p>Изменяемые объекты имеют поля, которые можно изменить; неизменяемые объекты не имеют полей, которые можно изменить после создания объекта</p>
    <p>Изменяемые объекты имеют поля, которые можно изменить; неизменяемые объекты не имеют полей, которые можно изменить после создания объекта</p>
</details>

