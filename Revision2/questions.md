<details><summary>маршалинг/анмаршалинг</summary>
    <p><b>Маршалинг</b> - процесс преобразования информации хранящейся в оперативной памяти, в формат, для хранения или передачи</p>
    <p>Обычно применяется тогда, когда информацию (данные, объекты) необходимо передавать между различными частями одной программы или от одной программы к другой.</p>
    <p>Разница между сериализация в том, что мы не можем маршалировать и демаршалировать объект в эквивалентный по статусу экземпляр другого класса.<br>
        А сериализация означает, что мы можем сохранить объект и повторно получить эквивалентное состояние, даже если это экземпляр другого класса
    </p>
</details>

<details><summary>Способы сериализации объекта</summary>   
    <a href="https://java-online.ru/blog-serialization.xhtml">Сериализация объектов</a><br>
    <ol>
        <li>
            <ul>Реализовать интерфейс <b>Serializable</b> - применяется стандартный алгоритм сериализации, который с помощью рефлексии выполняет:
                <li>запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса),</li>
                <li>рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно)</li>
                <li>запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса</li>
                <li>рекурсивную запись объектов, которые являются полями сериализуемого объекта</li>
            </ul>
        </li>
        <li>Реализовать интерфейс <b>Externalizable</b> - реализуется пользовательская логика в методах <b>writeExternal</b> и <b>readExternal</b><br>
            Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод <b>readExternal</b><br>
        </li>
    </ol>
</details>

<details><summary>GC - это</summary>
    <p><b>Garbage collection (сборка муора)</b> - это процесс автоматического управления памятью</p>
    <p>Освобождение памяти (путем очистки мусора) выполняется автоматически специальным компонентом JVM — сборщиком мусора (Garbage Collector, GC)</p>
</details>

<details><summary>LiveLock, Starvation</summary>
    <p><b>LiveLock</b> - тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, 
            попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются 
            в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в 
            результате попыток предотвращения deadlock
    </p>
    <p><b>Starvation</b> - это ситуация, когда параллельный поток не может получить все ресурсы, необходимые для выполнения его работы<br>
        Пример:<br>
        У нас будет два работника. Один жадный(greedyWorker), другой вежливый(politeWorker). Обоим дается одинаковое кол-во времени на их полезную работу — спать по 3 наносекунде.
        greedyWorker жадно удерживает общий ресурс(sharedLock) на протяжении всего цикла работы, тогда как politeWorker пытается блокировать его только тогда, когда это необходимо.6
    </p>
</details>

<details><summary>Мьютекс</summary>
    <p><b>Мьютекс</b> — это специальный объект для синхронизации потоков. Задача мьютекса — обеспечить такой механизм,
        чтобы доступ к объекту в определенное время был только у одного потока</p>
    <p><b>Мьютекс</b> - это просто семафор, который инициализирован начальным числом 1</p>
</details>

<details><summary>Что входит в cuncurrent?</summary>
    <ul>
        <li><b>Concurrent Collections</b> - набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета.</li>
        <li><b>Queues</b> - неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a</li>
        <li><b>Synchronizers</b> - вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях</li>
        <li><b>Executors</b> - содержит в себе фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов</li>
        <li><b>Locks</b> - представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll</li>
        <li><b>Atomics</b> - классы с поддержкой атомарных операций над примитивами и ссылками</li>
    </ul>
</details>

<details><summary>Locks</summary>
    <p><b>Lock</b> - это инструмент для управления доступом к общему ресурсу несколькими потоками<br>
        Реализации Lock обеспечивают более обширные операции блокировки, чем можно получить с помощью synchronized методов и операторов. Они допускают более гибкое структурирование, могут иметь совершенно разные свойства и могут поддерживать несколько связанных объектов условий (Condition)
    </p>
</details>

<details><summary>IO</summary>
    <p>Это API для работы с потоками данных, а конкретно чтения и записи</p>
</details>