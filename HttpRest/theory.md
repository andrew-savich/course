<details><summary>Что такое URI, URL, URN</summary>
    <p><b>URI</b> - Uniform Resource Identifier (унифицированный идентификатор ресурса), обозначает имя и адрес ресурса в сети. Как правило, делится на URL и URN</p>
    <p><b>URL</b> - Uniform Resource Locator (унифицированный определитель местонахождения ресурса)-адрес некоторого ресурса в веб. 
        URL определяет местонахождение ресурса и способ обращения к нему
    </p>
    <p><b>URN</b> - Unifrorm Resource Name (унифицированное имя ресурса) - Имя некоторого ресурса в веб. Смысл URN в том,
        что он определяет только название конкретного предмета, который может находится во множестве конкретных мест
    </p><br>
    <img src="src/main/resources/UriUrlUrn.png" width="30%">
</details>
<details><summary>Протокол HTTP, как устроен, как работает, зачем нужен</summary>
    <a href="https://habr.com/ru/post/215117/">Простым языком об HTTP</a><br>
    <p><b>HTTP (HyperText Transfer Protocol(протокол передачи гипертекста))</b> - протокол передачи данных.<br>
        Этот протокол описывает взаимодействие между двумя компьютерами (клиентом и сервером), построенное на базе сообщений, 
        называемых запрос (Request) и ответ (Response)<br>
        Изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных
    </p>
    <p>Протокол HTTP предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует 
        запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, 
        формирует ответ и передаёт его обратно клиенту
    </p>
    <ol>HTTP запросы и ответы имеют близкую структуру. Они состоят из:
        <li>Стартовой строки, описывающей запрос, или статус (успех или сбой). Это всегда одна строка</li>
        <li>Произвольного набора HTTP заголовков, определяющих запрос или описывающих тело сообщения</li>
        <li>Пустой строки, указывающей, что вся мета информация отправлена</li>
        <li>Произвольного тела, содержащего пересылаемые с запросом данные (например, содержимое HTML-формы ) или 
            отправляемый в ответ документ. Наличие тела и его размер определяется стартовой строкой и заголовками HTTP
        </li>
    </ol>
    <p>Стартовую строку вместе с заголовками сообщения HTTP называют головой запроса, а его данные - телом</p>
    <h3>Запросы</h3>
    <h4>Стартовая строка</h4>
    <ol>HTTP запросы - это сообщения, отправляемые клиентом, чтобы инициировать реакцию со стороны сервера. Их стартовая 
        строка состоит из трёх элементов:
        <li><b>Метод HTTP</b> - глагол (например, GET, PUT или POST) или существительное (например, HEAD или OPTIONS), 
            описывающие требуемое действие. Например, GET указывает, что нужно доставить некоторый ресурс, а POST означает 
            отправку данных на сервер (для создания или модификации ресурса, или генерации возвращаемого документа)
        </li>
        <li><b>Цель запроса</b> - обычно URL, или абсолютный путь протокола, порт и домен обычно характеризуются контекстом 
            запроса. Формат цели запроса зависит от используемого HTTP-метода. Это может быть
            <ul>
                <li>Абсолютный путь, за которым следует '?' и строка запроса. Это самая распространённая форма, называемая 
                    исходной формой (origin form) . Используется с методами GET, POST, HEAD, и OPTIONS. POST / HTTP 1.1 
                    GET /background.png HTTP/1.0 HEAD /test.html?query=alibaba HTTP/1.1 OPTIONS /anypage.html HTTP/1.0
                </li>
                <li>Полный URL - абсолютная форма (absolute form) , обычно используется с GET при подключении к прокси. 
                    GET http://developer.mozilla.org/ru/docs/Web/HTTP/Messages HTTP/1.1
                </li>
                <li>Компонента URL "authority", состоящая из имени домена и (необязательно) порта (предваряемого символом ':'),
                    называется authority form. Используется только с методом CONNECT при установке туннеля HTTP.<br>
                    CONNECT developer.mozilla.org:80 HTTP/1.1
                </li>
                <li>Форма звёздочки (asterisk form), просто "звёздочка" ('*') используется с методом OPTIONS и представляет сервер.<br>
                    OPTIONS * HTTP/1.1
                </li>
            </ul>
        </li>
        <li><b>Версия HTTP</b> - определяющая структуру оставшегося сообщения, указывая, какую версию предполагается использовать для ответа</li>
    </ol>
    <h4>Заголовки</h4>
    <p>Заголовки запроса HTTP имеют стандартную для заголовка HTTP структуру: не зависящая от регистра строка, завершаемая 
        (':') и значение, структура которого определяется заголовком. Весь заголовок, включая значение, представляет собой
        одну строку, которая может быть довольно длинной
    </p>
    <ul>Существует множество заголовков запроса. Их можно разделить на несколько групп:
        <li>Основные заголовки (General headers), например, Via (en-US), относящиеся к сообщению в целом</li>
        <li>Заголовки запроса (Request headers), например, User-Agent, Accept-Type, уточняющие запрос (как, например, 
            Accept-Language), придающие контекст (как Referer), или накладывающие ограничения на условия (like If-None)
        </li>
        <li>Заголовки сущности, например Content-Length, относящиеся к телу сообщения. Как легко понять, они отсутствуют, 
            если у запроса нет тела
        </li>
    </ul>
    <h4>Тело</h4>
    <p>Бывает не у всех запросов: запросы, собирающие (fetching) ресурсы, такие как GET, HEAD, DELETE, или OPTIONS, 
        в нем обычно не нуждаются. Но некоторые запросы отправляют на сервер данные для обновления, как это часто бывает 
        с запросами POST (содержащими данные HTML-форм)
    </p>
    <ul>Тела можно грубо разделить на две категории
        <li>Одноресурсные тела (Single-resource bodies), состоящие из одного отдельного файла, определяемого двумя заголовками: 
            Content-Type и Content-Length
        </li>
        <li>Многоресурсные тела (Multiple-resource bodies), состоящие из множества частей, каждая из которых содержит 
            свой бит информации. Они обычно связаны с HTML-формами
        </li>
    </ul>
    <h3>Ответы</h3>
    <h4>Строка статуса (Status line)</h4>
    <ol>Стартовая строка ответа HTTP, называемая строкой статуса, содержит следующую информацию:
        <li>Версию протокола, обычно HTTP/1.1</li>
        <li>Код состояния (status code), показывающая, был ли запрос успешным. Примеры: 200, 404 или 302</li>
        <li>Пояснение (status text). Краткое текстовое описание кода состояния, помогающее пользователю понять сообщение HTTP</li>
    </ol>
    <p>Пример<br>
        HTTP/1.1 404 Not Found
    </p>
    <h4>Заголовки</h4>
    <p>Заголовки ответов HTTP имеют ту же структуру, что и все остальные заголовки: не зависящая от регистра строка, 
        завершаемая двоеточием (':') и значение, структура которого определяется типом заголовка. Весь заголовок, c
        включая значение, представляет собой одну строку
    </p>
    <h4>Тело</h4>
    <p>Оно есть не у всех ответов: у ответов с кодом состояния, например, 201 или 204, оно обычно отсутствует</p>
    <ol>Тела можно разделить на три категории:
        <li>Одноресурсные тела (Single-resource bodies), состоящие из отдельного файла известной длины, определяемые двумя заголовками:
            Content-Type и Content-Length
        </li>
        <li>Одноресурсные тела (Single-resource bodies), состоящие из отдельного файла неизвестной длины, 
            разбитого на небольшие части (chunks) с заголовком Transfer-Encoding (en-US), значением которого является chunked
        </li>
        <li>Многоресурсные тела (Multiple-resource bodies), состоящие из многокомпонентного тела, каждая часть которого 
            содержит свой сегмент информации. Они относительно редки
        </li>
    </ol>
    <img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http-layers.png" width="25%"><br>
    <ul>Аспекты HTTP
        <li><b>простота</b> - HTTP-сообщения могут читаться и пониматься людьми, обеспечивая более лёгкое тестирование разработчиков и уменьшенную сложность для новых пользователей</li>
        <li><b>расширяемость</b> - Введённые в HTTP/1.0 HTTP-заголовки сделали этот протокол лёгким для расширения и экспериментирования. 
            Новая функциональность может быть даже введена простым соглашением между клиентом и сервером о семантике нового заголовка
        </li>
        <li><b>не имеет состояния, но имеет сессию</b> - не существует связи между двумя запросами, которые последовательно 
            выполняются по одному соединению. Из этого немедленно следует возможность проблем для пользователя, пытающегося 
            взаимодействовать с определённой страницей последовательно, например, при использовании корзины в электронном магазине. 
            Но хотя ядро HTTP не имеет состояния, куки позволяют использовать сессии с сохранением состояния. Используя расширяемость 
            заголовков, куки добавляются к рабочему потоку, позволяя сессии на каждом HTTP-запросе делиться некоторым контекстом или состоянием
        </li>
    </ul>
</details>
<details><summary>Методы протокола</summary>
    <p><b>Метод HTTP (англ. HTTP Method)</b> - последовательность из любых символов, кроме управляющих и разделителей, 
        указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, 
        записанное заглавными буквами (Табл. 1). Названия метода чувствительны к регистру
    </p>
    <ol>Все HTTP Methods можно разделить на три большие группы
        <li><b>Безопасные</b> — не меняют данные, можно выполнять их в любой последовательности. К ним относятся GET, HEAD и OPTIONS</li>
        <li><b>Идемпотентные </b> — когда вы получаете один и тот же ответ, сколько раз вы вызываете один и тот же ресурс,
            он известен как идемпотентный. Например, когда вы пытаетесь обновить одни и те же данные на сервере,
            ответ будет таким же для каждого запроса, сделанного с одинаковыми данными.<br>
            GET, HEAD, PUT, DELETE, OPTIONS, TRACE
        </li>
        <li><b>Неидемпотентные</b> — при повторном выполнении результаты будут отличаться. POST и PATCH</li>
    </ol>
    <img src="src/main/resources/methods.png" width="75%"><br>
    <h4>GET</h4>
    <p>Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. 
        В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса. Клиент может 
        передавать параметры выполнения запроса в URI целевого ресурса после символа «?»: GET /path/resource?param1=value1¶m2=value2 HTTP/1.1
    </p>
    <p>Согласно стандарту HTTP, запросы типа GET считаются идемпотентными[4] — многократное повторение одного и того же 
        запроса GET должно приводить к одинаковым результатам (при условии, что сам ресурс не изменился за время между запросами). 
        Это позволяет кэшировать ответы на запросы GET
    </p>
    <h4>HEAD</h4>
    <p>Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется 
        для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.<br>
        Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше копия ресурса помечается как устаревшая
    </p>
    <h4>POST</h4>
    <p>Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, 
        после чего они передаются серверу методом POST, и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются 
        в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы
    </p>
    <p>В отличие от метода GET, метод POST не считается идемпотентным[4], то есть многократное повторение одних и тех же 
        запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться одна 
        копия этого комментария)
    </p>
    <p>При результатах выполнения 200 (Ok) и 204 (No Content) в тело ответа следует включить сообщение об итоге выполнения запроса.
        Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location
    </p>
    <h4>PUT</h4>
    <p>Предназначен для создания новой или полного обновления существующей сущности. Может работать только с одой сущностью.
    </p>
    <h4>PATCH</h4>
    <p>Предназначен для частичного обновления существующей сущности</p>
    <h4>DELETE</h4>
    <p>Удаляет указанный ресурс</p>
    <h4>TRACE</h4>
    <p>Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе</p>
    <h4>CONNECT</h4>
    <p>Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно, чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси</p>
    <h4>OPTIONS</h4>
    <p>Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ 
        серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях
    </p>
</details>
<details><summary>Rest что такое, как устроено, что такое RESTfull и зачем нам нужен</summary>
    <p><b>REST (Representational State Transfer)</b> - архитектурный стиль взаимодействия компонентов распределённого приложения в сети.
        Другими словами, REST — это набор правил того, как программисту организовать написание кода серверного приложения,
        чтобы все системы легко обменивались данными и приложение можно было масштабировать
    </p>
    <h4>Принцип работы</h4>
    <p>REST API основывается на протоколе передачи гипертекста HTTP (Hypertext Transfer Protocol). Это стандартный протокол в интернете, 
        созданный для передачи гипертекста. Сейчас с помощью HTTP отправляют любые другие типы данных
    </p>
    <ul>Преимущества REST
        <li>Производительность</li>
        <li>Масштабируемость</li>
        <li>Гибкость к изменениям</li>
        <li>Отказоустойчивость</li>
        <li>Простота поддержки</li>
    </ul>
    <ul>В REST API есть 4 метода HTTP, которые используют для действий с объектами на серверах:
        <li>GET (получение информации о данных или списка объектов)</li>
        <li>DELETE (удаление данных)</li>
        <li>POST (добавление или замена данных)</li>
        <li>PUT (регулярное обновление данных)</li>
    </ul>
    <p>Такие запросы еще называют идентификаторами CRUD: create (создать), read (прочесть), update (обновить) delete (удалить)</p>
</details>
<details><summary>Принципы REST</summary>
    <h4>Клиент-серверная архитектура</h4>
    <p>заключается в разделении некоторых зон ответственности: в разделении функций клиента и сервера</p>
    <p>Например, мы разделяем нашу систему так, что клиент (допустим, это мобильное приложение) реализует только функциональное взаимодействие с сервером. 
        При этом сервер реализует в себе логику хранения данных, сложные взаимодействия со смежными системами и т.д.
    </p>
    <h4>Отсутствие записи состояния клиента (Stateless)</h4>
    <p>Сервер не должен хранить какой-либо информации о клиентах. В запросе должна храниться вся необходимая информация 
        для обработки запроса и если необходимо, идентификации клиента
    </p>
    <h4>Кэшируемость (Casheable)</h4>
    <p>В данных запроса должно быть указано, нужно ли кэшировать данные (сохранять в специальном буфере для частых запросов).
        Если такое указание есть, клиент получит право обращаться к этому буферу при необходимости<br>
        Это нужно и полезно, если у сервера часто запрашивают одинаковую информацию
    </p>
    <h4>Единство интерфейса (Uniform Interface)</h4>
    <p>Единый интерфейс определяет интерфейс между клиентами и серверами. Это упрощает и отделяет архитектуру, которая 
        позволяет каждой части развиваться самостоятельно
    </p>
    <ol>
        <li><b>Identification of resources (основан на ресурсах)</b> - В REST ресурсом является все то, чему можно дать имя. 
            Например,пользователь, изображение, предмет (майка, голодная собака, текущая погода) и т.д. Каждый ресурс в REST 
            должен быть идентифицирован посредством стабильного идентификатора, который не меняется при изменении состояния 
            ресурса. Идентификатором в REST является URI
        </li>
        <li><b>Manipulation of resources through representations. (Манипуляции над ресурсами через представления)</b> - 
            Представление в REST используется для выполнения действий над ресурсами. Представление ресурса представляет
            собой текущее или желаемое состояние ресурса. Например, если ресурсом является пользователь, то представлением 
            может являться XML или HTML описание этого пользователя.
        </li>
        <li><b>Self-descriptive messages (само-документируемые сообщения)</b> - Под само-описательностью имеется ввиду, 
            что запрос и ответ должны хранить в себе всю необходимую информацию для их обработки. Не должны быть дополнительные
            сообщения или кэши для обработки одного запроса. Другими словами отсутствие состояния, сохраняемого между запросами 
            к ресурсам. Это очень важно для масштабирования системы
        </li>
        <li><b>HATEOAS (hypermedia as the engine of application state)</b> - Статус ресурса передается через содержимое body, 
            параметры строки запроса, заголовки запросов и запрашиваемый URI (имя ресурса). Это называется гипермедиа 
            (или гиперссылки с гипертекстом). HATEOAS также означает, что, в случае необходимости ссылки могут содержатся
            в теле ответа (или заголовках) для поддержки URI, извлечения самого объекта или запрошенных объектов
        </li>
    </ol>
    <h4>Многоуровневость системы (Layered System)</h4>
    <p>Концепция многоуровневой архитектуры заключается в том, что ни клиент, ни сервер не должны знать о том, как 
        происходит цепочка вызовов дальше своих прямых соседей<br>
        В реальной жизни между ними могут быть, к примеру, proxy-сервера, роутеры, балансировщики и тд. 
        И то, по какому пути запрос проходит от клиента до сервера, мы часто не можем знать.
    </p>
    <h4>Предоставление кода по запросу (Code on Demand)</h4>
    <p>Серверы могут отправлять клиенту код (например, скрипт для запуска видео). Так общий код приложения или сайта 
        становится сложнее только при необходимости
    </p>
    <h4>Начало от нуля (Starting with the Null Style)</h4>
    <p>Клиент знает только одну точку входа на сервер. Дальнейшие возможности по взаимодействию обеспечиваются сервером</p>
</details>
<details><summary>Request Payload</summary>
    <p><b>Request Payload</b> - это любые данные, отправленные в теле запроса</p>
</details>
<details><summary>Что такое SOAP, почему его сравнивают с REST, в чем разница</summary>
    <p><b>SOAP (Simple Object Access Protocol)</b> - это протокол, по которому веб-сервисы взаимодействуют друг с другом 
        или с клиентами. SOAP API — это веб-сервис, использующий протокол SOAP для обмена сообщениями между серверами и 
        клиентами. При этом сообщения должны быть написаны на языке XML в соответствии со строгими стандартами, 
        иначе сервер вернет ошибку
    </p>
    <h4>Особенности</h4>
    <ul>Корректное SOAP-сообщение состоит из нескольких структурных элементов:<br>
        <img src="https://blog.skillfactory.ru/wp-content/uploads/2022/02/soap-2-1670174-1024x970.png" width="30%">
        <li><b>Envelope («конверт»)</b> - Это корневой элемент. Определяет XML-документ как сообщение SOAP с помощью 
            пространства имен xmlns:soap=»http://www.w3.org/2003/05/soap-envelope/». Если в определении будет указан 
            другой адрес, сервер вернет ошибку
        </li>
        <li><b>Header («заголовок»)</b> - Включает в себя атрибуты сообщения, связанные с конкретным приложением (аутентификация, 
            проведение платежей и т.д.). В заголовке могут использоваться три атрибута, которые указывают, как принимающая 
            сторона должна обрабатывать сообщение, — mustUnderstand, actor и encodingStyle.<br>
            Значение mustUnderstand — 1 или 0 — говорит принимающему приложению о том, следует ли распознавать заголовок в обязательном или опциональном порядке<br>
            Атрибут actor задает конкретную конечную точку для сообщения<br>
            Атрибут encodingStyle устанавливает специфическую кодировку для элемента.<br>
            По умолчанию SOAP-сообщение не имеет определенной кодировки
        </li>
        <li><b>Body («тело»)</b> - Сообщение, которое передает веб-приложение. Может содержать запрос к серверу или ответ от него</li>
        <li><b>Fault («ошибка»)</b> - Опциональный элемент. Передает уведомление об ошибках, если они возникли в ходе обработки сообщения.
            Может содержать вложенные элементы, которые проясняют причину возникновения ошибки:
            <ul>
                <li><b>faultcode</b> - код неполадки</li>
                <li><b>faultstring</b> - описание проблемы</li>
                <li><b>faultactor</b> - информация о программном компоненте, который вызвал ошибку</li>
                <li><b>detail</b> - дополнительные сведения о месте возникновения неполадки</li>
            </ul>
        </li>
    </ul>
    <h4>Отличия SOAP И REST</h4>
    <p>SOAP — протокол, а REST — архитектурный стиль, набор правил по написанию кода. REST был представлен в 2000 году. 
        К этому времени недостатки SOAP были очевидны:<br>
        объемные сообщения<br>
        поддержка только одного формата — XML<br>
        схема работы по принципу «один запрос — один ответ»<br>
        смена описания веб-сервиса может нарушить работу клиента<br>
    </p>
    <p>REST поддерживает несколько форматов помимо XML: JSON, TXT, CSV, HTML. Вместо создания громоздкой структуры 
        XML-запросов при использовании REST чаще всего можно передать нужный URL. Эти особенности делают стиль REST 
        простым и понятным, а приложения и веб-сервисы, использующие его, отличаются высокой производительностью и легко 
        масштабируются
    </p>
    <ul>Недостатки REST
        <li>при использовании REST сложнее обеспечить безопасность конфиденциальных данных</li>
        <li>трудности с проведением операций, которым необходимо сохранение состояния. Как, например, в случае с корзиной
            в онлайн-магазине, которая должна сохранять добавленные товары до момента оплаты
        </li>
    </ul>
    <ul>В каких случаях используют SOAP
        <li>Асинхронная обработка и последующий вызов. Стандарт SOAP 1.2 обеспечивает клиенту гарантированный уровень надежности и безопасности</li>
        <li>Формальное средство коммуникации. Если клиент и сервер имеют соглашение о формате обмена, то SOAP 1.2 
            предоставляет жесткие спецификации для такого типа взаимодействия. Пример — сайт онлайн-покупок, на котором 
            пользователи добавляют товары в корзину перед оплатой. Предположим, что есть веб-служба, которая выполняет 
            окончательный платеж. Может быть достигнуто соглашение, что веб-сервис будет принимать только название товара, 
            цену за единицу и количество. Если сценарий существует, лучше использовать протокол SOAP
        </li>
        <li>Операции с состоянием. Если приложение требует, чтобы состояние сохранялось от одного запроса к другому, 
            то стандарт SOAP 1.2 предоставляет структуру для поддержки таких требований
        </li>
    </ul>
</details>
<details><summary>Структура rest url</summary>
    <p>URL (англ. Uniform Resource Locator) - единообразный определитель местонахождения ресурса</p>
    <img src="https://tyapk.ru/storage/app/media/general/url.jpg" width="50%"><br>
    <img src="src/main/resources/img.png"><br>
    <ul>
        <li><b>схема</b> - схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол</li>
        <li><b>логин</b> - имя пользователя, используемое для доступа к ресурсу</li>
        <li><b>пароль</b> - пароль указанного пользователя</li>
        <li><b>хост</b> - полностью прописанное доменное имя хоста в системе DNS или IP-адрес</li>
        <li><b>порт</b> - порт хоста для подключения. Для http схемы используется по-умолчанию 80</li>
        <li><b>URL-путь</b> - уточняющая информация о месте нахождения ресурса; зависит от протокола</li>
        <li><b>параметры</b> - строка запроса с передаваемыми на сервер (методом GET) параметрами. Начинается с символа ?, 
            разделитель параметров — знак &. Пример: ?параметр_1=значение_1&параметр_2=значение_2&параметр3=значение_3
        </li>
        <li><b>якорь</b> - идентификатор «якоря» с предшествующим символом #. Якорем может быть указан заголовок внутри 
            документа или атрибут id элемента. По такой ссылке браузер откроет страницу и переместит окно к указанному элементу
        </li>
    </ul>
</details>
<details><summary>Логическая разница между XML и JSON</summary>
    <a href="https://coderlessons.com/tutorials/veb-razrabotka/arkhitektura-veb-servisov/10-json-protiv-xml">JSON против XML</a><br>
    <a href="https://webref.ru/dev/json-tutorial/json-vs-xml">JSON и XML</a><br>
    <p>JSON - это формат обмена данными, его цель — облегчить обмен структурированными данными. Это достигается путём непосредственного 
        представления объектов, массивов, чисел, строк и логических значений, которые часто присутствуют в исходном 
        окружении и в месте назначения
    </p>
    <p>XML - является языком разметки, его цель — разметка документа</p>
    <ul>КЛЮЧЕВАЯ РАЗНИЦА:
        <li>Объект JSON имеет тип, тогда как данные XML не содержат типов</li>
        <li>JSON не имеет возможностей отображения, тогда как XML предлагает возможность отображения данных</li>
        <li>JSON менее защищен, тогда как XML более безопасен по сравнению с JSON</li>
        <li>JSON поддерживает только кодировку UTF-8, тогда как XML поддерживает различные форматы кодирования</li>
    </ul>
</details>
<details><summary>Что помогает нам проверять, проектировать REST (приложения, фреймв)</summary>
    <ul>
        <li><b>TestNG</b> - тестирование REST API</li>
        <li><b>Postman</b> - приложение для мануального тестирования и проверки REST API</li>
        <li><b>Boomerang</b> - аналог Postman виде плагина для браузера</li>
        <li><b>Swagger</b> - для документирования REST</li>
    </ul>
</details>
<details><summary>HEAD (придумать пример)</summary>
    <p>Метод HEAD идентичен GET, за исключением того, что сервер не возвращает содержимое HTTP-ответа</p>
    <p>Когда вы отправляете запрос HEAD, это означает, что вас интересуют только код ответа и HTTP headers, а не сам документ</p>
    <p>Например, если у вас много ссылок на веб-сайте, вы можете периодически отправлять HEAD-запросы каждой из них, 
        чтобы проверить наличие неработающих ссылок. Это будет намного быстрее, чем при использовании GET
    </p>
</details>
<details><summary>Коды статуса HTTP</summary>
    <ul>
        <li>200 используются для успешных запросов</li>
        <li>300 для перенаправления</li>
        <li>400 используются, если возникла проблема с запросом</li>
        <li>500 используются, если возникла проблема с сервером</li>
    </ul>
    <h4>300</h4>
    <p><b>302 (or 307) Moved Temporarily & 301 Moved Permanently</b></p>
    <p>302 и 301 обрабатываются браузером очень похоже, но они могут иметь различные значения для spiders поисковых систем. 
        Например, если ваш сайт не готов для обслуживания, вы можете перенаправить его в другое место с помощью 302. 
        Поисковая система продолжит проверку вашей страницы в будущем. Но если вы перенаправите с использованием 301, 
        это сообщит spider, что ваш сайт переехал в это место навсегда. За более точной информацией: 
        http://www.nettuts.com перейдите на https://net.tutsplus.com/ используя 301 код вместо 302
    </p>
</details>
<details><summary>Заголовки HTTP в запросах HTTP</summary>
    <h4>Host</h4>
    <p>HTTP-запрос отправляется на определенные IP-адреса. Но так как большинство серверов способны размещать несколько сайтов под одним IP, 
        они должны знать, какое доменное имя ищет браузер:<br>
        Host: net.tutsplus.com
    </p>
    <h4>User-Agent</h4>
    <p>Этот заголовок может содержать несколько частей информации, таких как: имя и версия браузера; название и версия операционной системы;
        язык по умолчанию<br>
        Именно так веб-сайты могут собирать определённую общую информацию о своих
    </p>
    <h4>Accept-Language</h4>
    <p>Этот заголовок отображает настройки языка по умолчанию. Если сайт имеет разные языковые версии, он может перенаправить 
        нового пользователя на основе этих данных<br>
        Accept-Language: en-us,en;q=0.5
    </p>
</details>
