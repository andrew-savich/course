<details><summary>Что такое <b>многопоточность</b> и для чего она нам нужна</summary>
    <a href="https://habr.com/ru/post/164487/">Многопоточность в Java</a>
    <p><b>Многопоточность</b> - это процесс запуска нескольких потоков выполнения одновременно</p>
    <p>Многопоточность предназначена для эффективного и максимального использования процессорного времени</p>
</details>
<details><summary>Плюсы и минусы многопоточности</summary>
    <ol>Плюсы:
        <li>Возможность выполнения одновременно нескольких действий</li>
        <li>Ускорение/Оптимизация вычислений</li>
    </ol>
    <ol>Минусы:
        <li>Сложность реализации</li>
        <li></li>
    </ol>
</details>

<details><summary>Определение <b>процесса, потока, потока демона</b></summary>
    <a href="https://tproger.ru/problems/what-is-the-difference-between-threads-and-processes/">В чем разница между потоком и процессом?</a><br>
    <p><b>Процесс</b> - это экземпляр программы во время выполнения, является независимым объектом, которому выделены системные ресурсы (память, процессорное время)</p>
    <p>Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого.</p>
    <p>Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и тд</p>
    <br>
    <p><b>Поток</b> - это отдельное исполняемое задание внутри процесса, т.е. одна единица исполнения кода</p>
    <p>Процесс может содержать множество исполняемых потоков: при запуске процесса запускается основной потов исполнения, который может порождать другие потоки</p>
    <p>Потоки, запущенные внутри процесса, разделяют между собой память, выделенную для процесса</p>
    <br>
    <a href="https://ru.tutorialcup.com/java/daemon-thread-in-java.htm#:~:text=%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%20%D0%B4%D0%B5%D0%BC%D0%BE%D0%BD%D0%B0%20%D0%B2%20Java%20%2D%20%D1%8D%D1%82%D0%BE,%D0%94.">Поток демон</a><br>
    <p><b>Поток демона в Java</b> - это поток, генерируемый системой, который работает в фоновом режиме и поддерживает процесс потока пользователя. Он имеет низкий приоритет и выполняет такие задачи, как сборка мусора, финализатор и т.д.</p>
    <p>Запускается автоматически, и не нужно вызывать его отдельно. Срок службы потока демона зависит от пользовательского потока, что означает, что когда пользовательский поток завершается, JVM автоматически завершает потоки демона и не ожидает завершения потока демона</p>
    <p>Несмотря на то, что поток демона является потоком, генерируемым системой, можно установить новый поток как демон, а также проверить, является ли поток демоном или нет</p>
    <ul>Методы:
        <li><b>public final void setDaemon(boolean on)</b> - если параметр true, то устанавливает поток как демон. Можно вызывать только до запуска потока, иначе IllegalThreadStateException</li>
        <li><b>public final boolean isDaemon()</b> - проверяет или поток демон</li>
    </ul>
</details>

<details><summary>Разница между пользовательским потоком и потоком демоном</summary>
    <table>
        <tr>
            <th>Пользовательский поток</th>
            <th>Поток демон</th>
        </tr>
        <tr>
            <td>Высокий приоритетом</td>
            <td>Низкий приоритетом</td>
        </tr>
        <tr>
            <td>Работает на "переднем плане"</td>
            <td>Работает в фоновом режиме</td>
        </tr>
        <tr>
            <td>Выполняет конкретную задачу</td>
            <td>Выполняет вспомогательную задачу</td>
        </tr>
        <tr>
            <td>JVM всегда ожидает завершения активного пользовательского потока перед завершением работы	</td>
            <td>JVM не ждет завершения потока демона перед завершением работы</td>
        </tr>
        <tr>
            <td>Создано приложением Java для выполнения некоторой задачи</td>
            <td>Создано JVM</td>
        </tr>
        <tr>
            <td>Это независимый	</td>
            <td>Это зависит от пользовательских потоков</td>
        </tr>
    </table>
</details>

<details><summary>Псевдо-параллельность</summary>
    <p>Это вид параллелизма, при котором создается видимость паралленьного исполнения задач, потоков, за счет разделения процессорного времени выполнения</p>
    <p>Происходит на однопроцессорных (одноядерных) системах, и обычно управляется ОС</p>
</details>

<details><summary>Жизненный цикл потоков</summary>
    <p>В течение жизненного цикла потоки проходят через множество различных состояний</p>
    <img src="https://russianblogs.com/images/306/4ee6e99a67666c9c8a89359b4cbf32ca.png"><br>
    <ol>В любой момент времени поток может находиться только в одном из следующих состояний:
        <li><b>NEW</b> - новый созданный не запущенный поток</li>
        <li><b>RUNNABLE</b> - выполняется или готовится к запуску ожидая выделения ресурсов</li>
        <li><b>BLOCKED</b> -поток приостановил выполнение, поскольку ожидает получения блокировки монитора</li>
        <li><b>WAITING</b> - приостановлен и ожидает, что какой-то другой поток выполнит определенное действие без ограничения по времени</li>
        <li><b>TIMED_WAITING</b> - приостановлен и ожидает определенный промежуток времени</li>
        <li><b>TERMINATED</b> - завершил выполнение</li>
    </ol>
    <h4>NEW:</h4>
    <p>При инициализации экземпляра потока, поток находится в состоянии <b>NEW</b> до тех пор пока на нем мы не вызовем метод <b>start()</b></p>
    <h4>Runnable:</h4>
    <p>После запуска метода <b>start()</b> на экземпляре потока, поток перекдючается в режим <b>RUNNABLE</b> - что поток начал выполнение, либо
        готовится к выполнению, ожидая выделения ресурсов (например ЦП)
    </p>
    <p>В многопоточной среде плонировщик потоков выделяет для каждого потока определенное время, и относительно этого запускает каждый поток,
        который находится в состоянии RUNNABLE
    </p>
    <h4>Blocked:</h4>
    <p>Поток входит в это состояние, когда ожидает блокировки монитора и пытается получить доступ к разделу кода, который заблокирован другим потоком</p>
    <h4>Waiting:</h4>
    <p>Поток находится в состоянии <b>WAITING</b>, когда он ожидает, пока какой-либо другой поток выполнит определенное действие</p>
    <ul>это состояние достигается вызовом одного из методов:
        <li><b>object.wait()</b> - вызывающий поток останавливает свое выполнение до тех пор, пока не будет вызван метод notify() или notifyAll() каким-либо другим потоком</li>
        <li><b>thread.join()</b> - поток, на экземпляре которого, вызывается этот метод, переключится в режим <b>WAITING</b>, пока поток, в котором он вызывается, не будет завершен</li>
        <li><b>LockSupport.park()</b> - </li>
    </ul>
    <h4>Timed_Waiting:</h4>
    <p>Когда поток ожидает, пока другой поток выполнит определенное действие в течение указанного времени</p>
    <ol>способЫ заставить поток войти в состояние TIMED_WAITING:
        <li><b>thread.sleep(long millis)</b></li>
        <li><b>wait(int timeout)</b> или <b>wait(int timeout, int nanos)</b></li>
        <li><b>thread.join(long millis)</b></li>
        <li><b>LockSupport.parkNanos</b></li>
        <li><b>LockSupport.parkUntil</b></li>
    </ol>
    <h4>Terminated:</h4>
    <p>Когда поток завершает работу или аварийно завершается, он переходит в состояние TERMINATED</p>
</details>
<details><summary>Область видимости ресурсов потоками</summary>
    <a href="https://habr.com/ru/post/510454/">Java-модель памяти (часть 1)</a><br>
    <p>Каждый поток в Java имеет собственный стек. Стек содержит информацию о том, какие методы вызвал поток. Стек потока содержит все локальные переменные для каждого выполняемого метода. Поток может получить доступ только к своему стеку</p>
    <p>Локальные переменные, невидимы для всех других потоков, кроме потока, который их создал. Даже если два потока выполняют один и тот же код, они всё равно будут создавать локальные переменные этого кода в своих собственных стеках. Таким образом, каждый поток имеет свою версию каждой локальной переменной</p>
    <p>Все локальные переменные примитивных типов (boolean, byte, short, char, int, long, float, double) полностью хранятся в стеке потоков и не видны другим потокам. Один поток может передать копию примитивной переменной другому потоку, но не может совместно использовать примитивную локальную переменную.</p>
    <p>Локальная переменная может быть примитивного типа, в этом случае она полностью хранится в стеке потока.</p>
    <p>Локальная переменная также может быть ссылкой на объект. В этом случае ссылка (локальная переменная) хранится в стеке потоков, но сам объект хранится в куче</p>
    <p>Переменные-члены объекта хранятся в куче вместе с самим объектом. Это верно как в случае, когда переменная-член имеет примитивный тип, так и в том случае, если она является ссылкой на объект.</p>
    <p>Статические переменные класса также хранятся в куче вместе с определением класса.</p>
    <p>К объектам в куче могут обращаться все потоки, имеющие ссылку на объект. Когда поток имеет доступ к объекту, он также может получить доступ к переменным-членам этого объекта. Если два потока вызывают метод для одного и того же объекта одновременно, они оба будут иметь доступ к переменным-членам объекта, но каждый поток будет иметь свою собственную копию локальных переменных</p>
    <img src="https://habrastorage.org/webt/lq/yu/0n/lqyu0n9gj6rlphx3epgydd3ea-g.png">
</details>
<details><summary>Volatile</summary>
    <p><b>Volatile</b> - ключевое слово, означает, что значение переменной будет изменяться разными потоками</p>
    <ol>Основы:
        <li>Операции чтения/записи volatile переменной являются атомарными</li>
        <li>Результат операции записи значения в volatile переменную одним потоком, становится виден всем другим потокам, которые используют эту переменную для чтения из нее значения</li>
    </ol>
</details>
<details><summary>Способы создания потоков Java</summary>
    <a href="https://russianblogs.com/article/9415826053/">разница между Thread, Runnable и Callable</a><br>
    <ul>Есть различные способы создания потоков, например:
        <li>Расширить класс Thread, переопределить метод run(), вызвать метод start() на экземпляре класса</li>
        <li>Реализовать интерфейс Runnable, переопределить метод run(), экземпляр класса реализующего Runnable передать в качестве параметра при инициализации объекта класса Thread, и вызвать метод start()</li>
        <li>Реализуйте интерфейс Callable для реализации его метода call(), который выполняется через FutureTask</li>
    </ul>
    <p>Выбор между Thread или Runnable обусловлен отсутствием возможности множественного наследования</p>
    <p>
        Runnable доступен с Java 1.1, Callable с 1.5. Метод call() возвращает значения после выполненияб run() - нет. call() - может бросать исключения
    </p>
</details>